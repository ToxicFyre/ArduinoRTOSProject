
ArduinoRTOSProject.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002638  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000043c  20000000  00002638  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000407c  2000043c  00002a74  0002043c  2**2
                  ALLOC
  3 .stack        00002000  200044b8  00006af0  0002043c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0002043c  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020464  2**0
                  CONTENTS, READONLY
  6 .debug_info   000186f7  00000000  00000000  000204bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001e7f  00000000  00000000  00038bb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000062b9  00000000  00000000  0003aa33  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000005e8  00000000  00000000  00040cec  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000007c0  00000000  00000000  000412d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00011d35  00000000  00000000  00041a94  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000057fd  00000000  00000000  000537c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0007a4c8  00000000  00000000  00058fc6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000011c4  00000000  00000000  000d3490  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	b8 64 00 20 19 01 00 00 15 01 00 00 15 01 00 00     .d. ............
	...
      2c:	15 01 00 00 00 00 00 00 00 00 00 00 41 0a 00 00     ............A...
      3c:	85 0a 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      4c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      5c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      6c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      7c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      8c:	15 01 00 00 15 01 00 00 00 00 00 00 00 00 00 00     ................
      9c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      ac:	15 01 00 00 00 00 00 00                             ........

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	2000043c 	.word	0x2000043c
      d4:	00000000 	.word	0x00000000
      d8:	00002638 	.word	0x00002638

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000440 	.word	0x20000440
     108:	00002638 	.word	0x00002638
     10c:	00002638 	.word	0x00002638
     110:	00000000 	.word	0x00000000

00000114 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     114:	e7fe      	b.n	114 <Dummy_Handler>
	...

00000118 <Reset_Handler>:
{
     118:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
     11a:	4a2a      	ldr	r2, [pc, #168]	; (1c4 <Reset_Handler+0xac>)
     11c:	4b2a      	ldr	r3, [pc, #168]	; (1c8 <Reset_Handler+0xb0>)
     11e:	429a      	cmp	r2, r3
     120:	d011      	beq.n	146 <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
     122:	001a      	movs	r2, r3
     124:	4b29      	ldr	r3, [pc, #164]	; (1cc <Reset_Handler+0xb4>)
     126:	429a      	cmp	r2, r3
     128:	d20d      	bcs.n	146 <Reset_Handler+0x2e>
     12a:	4a29      	ldr	r2, [pc, #164]	; (1d0 <Reset_Handler+0xb8>)
     12c:	3303      	adds	r3, #3
     12e:	1a9b      	subs	r3, r3, r2
     130:	089b      	lsrs	r3, r3, #2
     132:	3301      	adds	r3, #1
     134:	009b      	lsls	r3, r3, #2
     136:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
     138:	4823      	ldr	r0, [pc, #140]	; (1c8 <Reset_Handler+0xb0>)
     13a:	4922      	ldr	r1, [pc, #136]	; (1c4 <Reset_Handler+0xac>)
     13c:	588c      	ldr	r4, [r1, r2]
     13e:	5084      	str	r4, [r0, r2]
     140:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     142:	429a      	cmp	r2, r3
     144:	d1fa      	bne.n	13c <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
     146:	4a23      	ldr	r2, [pc, #140]	; (1d4 <Reset_Handler+0xbc>)
     148:	4b23      	ldr	r3, [pc, #140]	; (1d8 <Reset_Handler+0xc0>)
     14a:	429a      	cmp	r2, r3
     14c:	d20a      	bcs.n	164 <Reset_Handler+0x4c>
     14e:	43d3      	mvns	r3, r2
     150:	4921      	ldr	r1, [pc, #132]	; (1d8 <Reset_Handler+0xc0>)
     152:	185b      	adds	r3, r3, r1
     154:	2103      	movs	r1, #3
     156:	438b      	bics	r3, r1
     158:	3304      	adds	r3, #4
     15a:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
     15c:	2100      	movs	r1, #0
     15e:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
     160:	4293      	cmp	r3, r2
     162:	d1fc      	bne.n	15e <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     164:	4a1d      	ldr	r2, [pc, #116]	; (1dc <Reset_Handler+0xc4>)
     166:	21ff      	movs	r1, #255	; 0xff
     168:	4b1d      	ldr	r3, [pc, #116]	; (1e0 <Reset_Handler+0xc8>)
     16a:	438b      	bics	r3, r1
     16c:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     16e:	39fd      	subs	r1, #253	; 0xfd
     170:	2390      	movs	r3, #144	; 0x90
     172:	005b      	lsls	r3, r3, #1
     174:	4a1b      	ldr	r2, [pc, #108]	; (1e4 <Reset_Handler+0xcc>)
     176:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     178:	4a1b      	ldr	r2, [pc, #108]	; (1e8 <Reset_Handler+0xd0>)
     17a:	78d3      	ldrb	r3, [r2, #3]
     17c:	2503      	movs	r5, #3
     17e:	43ab      	bics	r3, r5
     180:	2402      	movs	r4, #2
     182:	4323      	orrs	r3, r4
     184:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     186:	78d3      	ldrb	r3, [r2, #3]
     188:	270c      	movs	r7, #12
     18a:	43bb      	bics	r3, r7
     18c:	2608      	movs	r6, #8
     18e:	4333      	orrs	r3, r6
     190:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     192:	4b16      	ldr	r3, [pc, #88]	; (1ec <Reset_Handler+0xd4>)
     194:	7b98      	ldrb	r0, [r3, #14]
     196:	2230      	movs	r2, #48	; 0x30
     198:	4390      	bics	r0, r2
     19a:	2220      	movs	r2, #32
     19c:	4310      	orrs	r0, r2
     19e:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     1a0:	7b99      	ldrb	r1, [r3, #14]
     1a2:	43b9      	bics	r1, r7
     1a4:	4331      	orrs	r1, r6
     1a6:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     1a8:	7b9a      	ldrb	r2, [r3, #14]
     1aa:	43aa      	bics	r2, r5
     1ac:	4322      	orrs	r2, r4
     1ae:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     1b0:	4a0f      	ldr	r2, [pc, #60]	; (1f0 <Reset_Handler+0xd8>)
     1b2:	6853      	ldr	r3, [r2, #4]
     1b4:	2180      	movs	r1, #128	; 0x80
     1b6:	430b      	orrs	r3, r1
     1b8:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     1ba:	4b0e      	ldr	r3, [pc, #56]	; (1f4 <Reset_Handler+0xdc>)
     1bc:	4798      	blx	r3
        main();
     1be:	4b0e      	ldr	r3, [pc, #56]	; (1f8 <Reset_Handler+0xe0>)
     1c0:	4798      	blx	r3
     1c2:	e7fe      	b.n	1c2 <Reset_Handler+0xaa>
     1c4:	00002638 	.word	0x00002638
     1c8:	20000000 	.word	0x20000000
     1cc:	2000043c 	.word	0x2000043c
     1d0:	20000004 	.word	0x20000004
     1d4:	2000043c 	.word	0x2000043c
     1d8:	200044b8 	.word	0x200044b8
     1dc:	e000ed00 	.word	0xe000ed00
     1e0:	00000000 	.word	0x00000000
     1e4:	41007000 	.word	0x41007000
     1e8:	41005000 	.word	0x41005000
     1ec:	41004800 	.word	0x41004800
     1f0:	41004000 	.word	0x41004000
     1f4:	0000228d 	.word	0x0000228d
     1f8:	00000529 	.word	0x00000529

000001fc <SystemInit>:
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
        // Keep the default device state after reset
        SystemCoreClock = __SYSTEM_CLOCK;
     1fc:	4a01      	ldr	r2, [pc, #4]	; (204 <SystemInit+0x8>)
     1fe:	4b02      	ldr	r3, [pc, #8]	; (208 <SystemInit+0xc>)
     200:	601a      	str	r2, [r3, #0]
        return;
}
     202:	4770      	bx	lr
     204:	000f4240 	.word	0x000f4240
     208:	20000000 	.word	0x20000000

0000020c <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     20c:	b570      	push	{r4, r5, r6, lr}
     20e:	0004      	movs	r4, r0
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     210:	4b2a      	ldr	r3, [pc, #168]	; (2bc <pvPortMalloc+0xb0>)
     212:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     214:	4b2a      	ldr	r3, [pc, #168]	; (2c0 <pvPortMalloc+0xb4>)
     216:	689b      	ldr	r3, [r3, #8]
     218:	2b00      	cmp	r3, #0
     21a:	d011      	beq.n	240 <pvPortMalloc+0x34>
void *pvReturn = NULL;
     21c:	2500      	movs	r5, #0
			xHeapHasBeenInitialised = pdTRUE;
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     21e:	2c00      	cmp	r4, #0
     220:	d046      	beq.n	2b0 <pvPortMalloc+0xa4>
		{
			xWantedSize += heapSTRUCT_SIZE;
     222:	0020      	movs	r0, r4
     224:	3008      	adds	r0, #8

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
     226:	0743      	lsls	r3, r0, #29
     228:	d002      	beq.n	230 <pvPortMalloc+0x24>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
     22a:	2307      	movs	r3, #7
     22c:	4398      	bics	r0, r3
     22e:	3008      	adds	r0, #8
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     230:	1e43      	subs	r3, r0, #1
     232:	4a24      	ldr	r2, [pc, #144]	; (2c4 <pvPortMalloc+0xb8>)
void *pvReturn = NULL;
     234:	2500      	movs	r5, #0
		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     236:	4293      	cmp	r3, r2
     238:	d83a      	bhi.n	2b0 <pvPortMalloc+0xa4>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     23a:	4921      	ldr	r1, [pc, #132]	; (2c0 <pvPortMalloc+0xb4>)
     23c:	680b      	ldr	r3, [r1, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     23e:	e013      	b.n	268 <pvPortMalloc+0x5c>
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     240:	491f      	ldr	r1, [pc, #124]	; (2c0 <pvPortMalloc+0xb4>)
     242:	000b      	movs	r3, r1
     244:	3314      	adds	r3, #20
     246:	2207      	movs	r2, #7
     248:	4393      	bics	r3, r2

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     24a:	600b      	str	r3, [r1, #0]
	xStart.xBlockSize = ( size_t ) 0;
     24c:	2500      	movs	r5, #0
     24e:	604d      	str	r5, [r1, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     250:	4a1d      	ldr	r2, [pc, #116]	; (2c8 <pvPortMalloc+0xbc>)
     252:	481e      	ldr	r0, [pc, #120]	; (2cc <pvPortMalloc+0xc0>)
     254:	6110      	str	r0, [r2, #16]
	xEnd.pxNextFreeBlock = NULL;
     256:	60d5      	str	r5, [r2, #12]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     258:	6058      	str	r0, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     25a:	320c      	adds	r2, #12
     25c:	601a      	str	r2, [r3, #0]
			xHeapHasBeenInitialised = pdTRUE;
     25e:	2301      	movs	r3, #1
     260:	608b      	str	r3, [r1, #8]
     262:	e7db      	b.n	21c <pvPortMalloc+0x10>
     264:	0019      	movs	r1, r3
				pxBlock = pxBlock->pxNextFreeBlock;
     266:	0013      	movs	r3, r2
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     268:	685a      	ldr	r2, [r3, #4]
     26a:	4290      	cmp	r0, r2
     26c:	d902      	bls.n	274 <pvPortMalloc+0x68>
     26e:	681a      	ldr	r2, [r3, #0]
     270:	2a00      	cmp	r2, #0
     272:	d1f7      	bne.n	264 <pvPortMalloc+0x58>
			if( pxBlock != &xEnd )
     274:	4a14      	ldr	r2, [pc, #80]	; (2c8 <pvPortMalloc+0xbc>)
     276:	320c      	adds	r2, #12
     278:	4293      	cmp	r3, r2
     27a:	d01d      	beq.n	2b8 <pvPortMalloc+0xac>
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     27c:	680d      	ldr	r5, [r1, #0]
     27e:	3508      	adds	r5, #8
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     280:	681a      	ldr	r2, [r3, #0]
     282:	600a      	str	r2, [r1, #0]
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     284:	685a      	ldr	r2, [r3, #4]
     286:	1a12      	subs	r2, r2, r0
     288:	2a10      	cmp	r2, #16
     28a:	d90c      	bls.n	2a6 <pvPortMalloc+0x9a>
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     28c:	181c      	adds	r4, r3, r0
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     28e:	6062      	str	r2, [r4, #4]
					pxBlock->xBlockSize = xWantedSize;
     290:	6058      	str	r0, [r3, #4]
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     292:	6860      	ldr	r0, [r4, #4]
     294:	490a      	ldr	r1, [pc, #40]	; (2c0 <pvPortMalloc+0xb4>)
     296:	e000      	b.n	29a <pvPortMalloc+0x8e>
     298:	0011      	movs	r1, r2
     29a:	680a      	ldr	r2, [r1, #0]
     29c:	6856      	ldr	r6, [r2, #4]
     29e:	42b0      	cmp	r0, r6
     2a0:	d8fa      	bhi.n	298 <pvPortMalloc+0x8c>
     2a2:	6022      	str	r2, [r4, #0]
     2a4:	600c      	str	r4, [r1, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     2a6:	4a0a      	ldr	r2, [pc, #40]	; (2d0 <pvPortMalloc+0xc4>)
     2a8:	685b      	ldr	r3, [r3, #4]
     2aa:	6811      	ldr	r1, [r2, #0]
     2ac:	1acb      	subs	r3, r1, r3
     2ae:	6013      	str	r3, [r2, #0]
	( void ) xTaskResumeAll();
     2b0:	4b08      	ldr	r3, [pc, #32]	; (2d4 <pvPortMalloc+0xc8>)
     2b2:	4798      	blx	r3
}
     2b4:	0028      	movs	r0, r5
     2b6:	bd70      	pop	{r4, r5, r6, pc}
void *pvReturn = NULL;
     2b8:	2500      	movs	r5, #0
     2ba:	e7f9      	b.n	2b0 <pvPortMalloc+0xa4>
     2bc:	00001831 	.word	0x00001831
     2c0:	20000458 	.word	0x20000458
     2c4:	00003e76 	.word	0x00003e76
     2c8:	200042d8 	.word	0x200042d8
     2cc:	00003e78 	.word	0x00003e78
     2d0:	20000004 	.word	0x20000004
     2d4:	0000195d 	.word	0x0000195d

000002d8 <vPortFree>:
{
     2d8:	b570      	push	{r4, r5, r6, lr}
     2da:	1e04      	subs	r4, r0, #0
	if( pv != NULL )
     2dc:	d016      	beq.n	30c <vPortFree+0x34>
		puc -= heapSTRUCT_SIZE;
     2de:	0005      	movs	r5, r0
     2e0:	3d08      	subs	r5, #8
		vTaskSuspendAll();
     2e2:	4b0b      	ldr	r3, [pc, #44]	; (310 <vPortFree+0x38>)
     2e4:	4798      	blx	r3
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     2e6:	6869      	ldr	r1, [r5, #4]
     2e8:	4a0a      	ldr	r2, [pc, #40]	; (314 <vPortFree+0x3c>)
     2ea:	e000      	b.n	2ee <vPortFree+0x16>
     2ec:	001a      	movs	r2, r3
     2ee:	6813      	ldr	r3, [r2, #0]
     2f0:	6858      	ldr	r0, [r3, #4]
     2f2:	4281      	cmp	r1, r0
     2f4:	d8fa      	bhi.n	2ec <vPortFree+0x14>
     2f6:	3c08      	subs	r4, #8
     2f8:	6023      	str	r3, [r4, #0]
     2fa:	6015      	str	r5, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
     2fc:	4a06      	ldr	r2, [pc, #24]	; (318 <vPortFree+0x40>)
     2fe:	6863      	ldr	r3, [r4, #4]
     300:	6811      	ldr	r1, [r2, #0]
     302:	468c      	mov	ip, r1
     304:	4463      	add	r3, ip
     306:	6013      	str	r3, [r2, #0]
		( void ) xTaskResumeAll();
     308:	4b04      	ldr	r3, [pc, #16]	; (31c <vPortFree+0x44>)
     30a:	4798      	blx	r3
}
     30c:	bd70      	pop	{r4, r5, r6, pc}
     30e:	46c0      	nop			; (mov r8, r8)
     310:	00001831 	.word	0x00001831
     314:	20000458 	.word	0x20000458
     318:	20000004 	.word	0x20000004
     31c:	0000195d 	.word	0x0000195d

00000320 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     320:	0003      	movs	r3, r0
     322:	3308      	adds	r3, #8
     324:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     326:	2201      	movs	r2, #1
     328:	4252      	negs	r2, r2
     32a:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     32c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     32e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     330:	2300      	movs	r3, #0
     332:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     334:	4770      	bx	lr

00000336 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     336:	2300      	movs	r3, #0
     338:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     33a:	4770      	bx	lr

0000033c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
     33c:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     33e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     340:	689a      	ldr	r2, [r3, #8]
     342:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     344:	689a      	ldr	r2, [r3, #8]
     346:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
     348:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     34a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     34c:	6803      	ldr	r3, [r0, #0]
     34e:	3301      	adds	r3, #1
     350:	6003      	str	r3, [r0, #0]
}
     352:	4770      	bx	lr

00000354 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     354:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     356:	680c      	ldr	r4, [r1, #0]
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     358:	0002      	movs	r2, r0
     35a:	3208      	adds	r2, #8
	if( xValueOfInsertion == portMAX_DELAY )
     35c:	1c63      	adds	r3, r4, #1
     35e:	d102      	bne.n	366 <vListInsert+0x12>
		pxIterator = pxList->xListEnd.pxPrevious;
     360:	6902      	ldr	r2, [r0, #16]
     362:	e004      	b.n	36e <vListInsert+0x1a>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     364:	001a      	movs	r2, r3
     366:	6853      	ldr	r3, [r2, #4]
     368:	681d      	ldr	r5, [r3, #0]
     36a:	42ac      	cmp	r4, r5
     36c:	d2fa      	bcs.n	364 <vListInsert+0x10>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     36e:	6853      	ldr	r3, [r2, #4]
     370:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     372:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
     374:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
     376:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     378:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     37a:	6803      	ldr	r3, [r0, #0]
     37c:	3301      	adds	r3, #1
     37e:	6003      	str	r3, [r0, #0]
}
     380:	bd30      	pop	{r4, r5, pc}

00000382 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     382:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     384:	6842      	ldr	r2, [r0, #4]
     386:	6881      	ldr	r1, [r0, #8]
     388:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     38a:	6882      	ldr	r2, [r0, #8]
     38c:	6841      	ldr	r1, [r0, #4]
     38e:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     390:	685a      	ldr	r2, [r3, #4]
     392:	4290      	cmp	r0, r2
     394:	d006      	beq.n	3a4 <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     396:	2200      	movs	r2, #0
     398:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
     39a:	681a      	ldr	r2, [r3, #0]
     39c:	3a01      	subs	r2, #1
     39e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     3a0:	6818      	ldr	r0, [r3, #0]
}
     3a2:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     3a4:	6882      	ldr	r2, [r0, #8]
     3a6:	605a      	str	r2, [r3, #4]
     3a8:	e7f5      	b.n	396 <uxListRemove+0x14>
	...

000003ac <CheckRx>:
xQueueHandle Global_Queue_Handle = 0;
xQueueHandle Door_Queue_Handle = 1;
xSemaphoreHandle rx_binary_sem;

void CheckRx(void)
{
     3ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	while (1)
	{
		do 
		{
			myprintf("X");
     3ae:	4d09      	ldr	r5, [pc, #36]	; (3d4 <CheckRx+0x28>)
     3b0:	4e09      	ldr	r6, [pc, #36]	; (3d8 <CheckRx+0x2c>)
			vTaskDelay(100);
     3b2:	4c0a      	ldr	r4, [pc, #40]	; (3dc <CheckRx+0x30>)
			myprintf("X");
     3b4:	0028      	movs	r0, r5
     3b6:	47b0      	blx	r6
			vTaskDelay(100);
     3b8:	2064      	movs	r0, #100	; 0x64
     3ba:	47a0      	blx	r4
		} while(!(SERCOM0->USART.INTFLAG.bit.RXC));
     3bc:	4b08      	ldr	r3, [pc, #32]	; (3e0 <CheckRx+0x34>)
     3be:	7e1b      	ldrb	r3, [r3, #24]
     3c0:	075b      	lsls	r3, r3, #29
     3c2:	d5f7      	bpl.n	3b4 <CheckRx+0x8>
		xSemaphoreGive(rx_binary_sem);
     3c4:	4b07      	ldr	r3, [pc, #28]	; (3e4 <CheckRx+0x38>)
     3c6:	6818      	ldr	r0, [r3, #0]
     3c8:	2300      	movs	r3, #0
     3ca:	2200      	movs	r2, #0
     3cc:	2100      	movs	r1, #0
     3ce:	4f06      	ldr	r7, [pc, #24]	; (3e8 <CheckRx+0x3c>)
     3d0:	47b8      	blx	r7
	while (1)
     3d2:	e7ef      	b.n	3b4 <CheckRx+0x8>
     3d4:	00002544 	.word	0x00002544
     3d8:	000006fd 	.word	0x000006fd
     3dc:	00001a51 	.word	0x00001a51
     3e0:	42000800 	.word	0x42000800
     3e4:	2000444c 	.word	0x2000444c
     3e8:	00000d55 	.word	0x00000d55

000003ec <PingRasp>:
	}
}

void PingRasp(void *p) {
     3ec:	b5f0      	push	{r4, r5, r6, r7, lr}
     3ee:	b083      	sub	sp, #12

	while (1) {
		uint8_t rx_data;
		if(xSemaphoreTake(rx_binary_sem, ( TickType_t ) 3000 ) == pdTRUE)
     3f0:	4e0c      	ldr	r6, [pc, #48]	; (424 <PingRasp+0x38>)
     3f2:	4c0d      	ldr	r4, [pc, #52]	; (428 <PingRasp+0x3c>)
			xQueueSend(Global_Queue_Handle, &rx_data, 2000);
		}
		else
		{
			//Send connection error here
			myprintf("UART Connection Error");
     3f4:	4d0d      	ldr	r5, [pc, #52]	; (42c <PingRasp+0x40>)
     3f6:	e00b      	b.n	410 <PingRasp+0x24>
			rx_data = SERCOM0->USART.DATA.reg;
     3f8:	4b0d      	ldr	r3, [pc, #52]	; (430 <PingRasp+0x44>)
     3fa:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
     3fc:	466a      	mov	r2, sp
     3fe:	1dd1      	adds	r1, r2, #7
     400:	700b      	strb	r3, [r1, #0]
			xQueueSend(Global_Queue_Handle, &rx_data, 2000);
     402:	4b0c      	ldr	r3, [pc, #48]	; (434 <PingRasp+0x48>)
     404:	6818      	ldr	r0, [r3, #0]
     406:	2300      	movs	r3, #0
     408:	22fa      	movs	r2, #250	; 0xfa
     40a:	00d2      	lsls	r2, r2, #3
     40c:	4f0a      	ldr	r7, [pc, #40]	; (438 <PingRasp+0x4c>)
     40e:	47b8      	blx	r7
		if(xSemaphoreTake(rx_binary_sem, ( TickType_t ) 3000 ) == pdTRUE)
     410:	490a      	ldr	r1, [pc, #40]	; (43c <PingRasp+0x50>)
     412:	6830      	ldr	r0, [r6, #0]
     414:	47a0      	blx	r4
     416:	2801      	cmp	r0, #1
     418:	d0ee      	beq.n	3f8 <PingRasp+0xc>
			myprintf("UART Connection Error");
     41a:	0028      	movs	r0, r5
     41c:	4b08      	ldr	r3, [pc, #32]	; (440 <PingRasp+0x54>)
     41e:	4798      	blx	r3
	while (1) {
     420:	e7f6      	b.n	410 <PingRasp+0x24>
     422:	46c0      	nop			; (mov r8, r8)
     424:	2000444c 	.word	0x2000444c
     428:	00001105 	.word	0x00001105
     42c:	00002548 	.word	0x00002548
     430:	42000800 	.word	0x42000800
     434:	200042ec 	.word	0x200042ec
     438:	00000d55 	.word	0x00000d55
     43c:	00000bb8 	.word	0x00000bb8
     440:	000006fd 	.word	0x000006fd

00000444 <HandleDoor>:
		}
	}
}

void HandleDoor(void *p)
{
     444:	b570      	push	{r4, r5, r6, lr}
	while (1)
	{
		static uint8_t rx_data = 0;
		if (xQueueReceive(Door_Queue_Handle, &rx_data, 1500))
     446:	4c0f      	ldr	r4, [pc, #60]	; (484 <HandleDoor+0x40>)
     448:	3404      	adds	r4, #4
     44a:	4e0f      	ldr	r6, [pc, #60]	; (488 <HandleDoor+0x44>)
     44c:	4d0f      	ldr	r5, [pc, #60]	; (48c <HandleDoor+0x48>)
     44e:	e006      	b.n	45e <HandleDoor+0x1a>
		{

			if (rx_data - '0' == 0)
			{
				PORT->Group[ 0 ].OUTCLR.reg = PORT_PA19;
     450:	2280      	movs	r2, #128	; 0x80
     452:	0312      	lsls	r2, r2, #12
     454:	4b0e      	ldr	r3, [pc, #56]	; (490 <HandleDoor+0x4c>)
     456:	615a      	str	r2, [r3, #20]
				myprintf("close door");
     458:	480e      	ldr	r0, [pc, #56]	; (494 <HandleDoor+0x50>)
     45a:	4b0f      	ldr	r3, [pc, #60]	; (498 <HandleDoor+0x54>)
     45c:	4798      	blx	r3
		if (xQueueReceive(Door_Queue_Handle, &rx_data, 1500))
     45e:	4a0f      	ldr	r2, [pc, #60]	; (49c <HandleDoor+0x58>)
     460:	0021      	movs	r1, r4
     462:	6830      	ldr	r0, [r6, #0]
     464:	47a8      	blx	r5
     466:	2800      	cmp	r0, #0
     468:	d0f9      	beq.n	45e <HandleDoor+0x1a>
			if (rx_data - '0' == 0)
     46a:	4b06      	ldr	r3, [pc, #24]	; (484 <HandleDoor+0x40>)
     46c:	791b      	ldrb	r3, [r3, #4]
     46e:	2b30      	cmp	r3, #48	; 0x30
     470:	d0ee      	beq.n	450 <HandleDoor+0xc>
			} 
			else
			{
				PORT->Group[ 0 ].OUTSET.reg = PORT_PA19;
     472:	2280      	movs	r2, #128	; 0x80
     474:	0312      	lsls	r2, r2, #12
     476:	4b06      	ldr	r3, [pc, #24]	; (490 <HandleDoor+0x4c>)
     478:	619a      	str	r2, [r3, #24]
				myprintf("open door");
     47a:	4809      	ldr	r0, [pc, #36]	; (4a0 <HandleDoor+0x5c>)
     47c:	4b06      	ldr	r3, [pc, #24]	; (498 <HandleDoor+0x54>)
     47e:	4798      	blx	r3
     480:	e7ed      	b.n	45e <HandleDoor+0x1a>
     482:	46c0      	nop			; (mov r8, r8)
     484:	200042ec 	.word	0x200042ec
     488:	20000008 	.word	0x20000008
     48c:	00000fb1 	.word	0x00000fb1
     490:	41004400 	.word	0x41004400
     494:	00002560 	.word	0x00002560
     498:	000006fd 	.word	0x000006fd
     49c:	000005dc 	.word	0x000005dc
     4a0:	0000256c 	.word	0x0000256c

000004a4 <PassData>:
void PassData(void *p) {
     4a4:	b5f0      	push	{r4, r5, r6, r7, lr}
     4a6:	b085      	sub	sp, #20
		if(xQueueReceive(Global_Queue_Handle, &rx_data, 1500))
     4a8:	4e16      	ldr	r6, [pc, #88]	; (504 <PassData+0x60>)
     4aa:	4f17      	ldr	r7, [pc, #92]	; (508 <PassData+0x64>)
			if (rx_data - '0' == 4)
     4ac:	0035      	movs	r5, r6
					xQueueSend(Door_Queue_Handle, &rx_data, 2000);
     4ae:	0033      	movs	r3, r6
     4b0:	3305      	adds	r3, #5
     4b2:	9301      	str	r3, [sp, #4]
     4b4:	e011      	b.n	4da <PassData+0x36>
				myprintf("Internet Connection Error");
     4b6:	4815      	ldr	r0, [pc, #84]	; (50c <PassData+0x68>)
     4b8:	4b15      	ldr	r3, [pc, #84]	; (510 <PassData+0x6c>)
     4ba:	4798      	blx	r3
     4bc:	e00d      	b.n	4da <PassData+0x36>
					xQueueSend(Door_Queue_Handle, &rx_data, 2000);
     4be:	4b15      	ldr	r3, [pc, #84]	; (514 <PassData+0x70>)
     4c0:	6818      	ldr	r0, [r3, #0]
     4c2:	2300      	movs	r3, #0
     4c4:	22fa      	movs	r2, #250	; 0xfa
     4c6:	00d2      	lsls	r2, r2, #3
     4c8:	490e      	ldr	r1, [pc, #56]	; (504 <PassData+0x60>)
     4ca:	3105      	adds	r1, #5
     4cc:	4c12      	ldr	r4, [pc, #72]	; (518 <PassData+0x74>)
     4ce:	47a0      	blx	r4
				receiveI2CDataArray((uint8_t)SLAVE_ADDR, pointer, (uint8_t)8);
     4d0:	2208      	movs	r2, #8
     4d2:	a902      	add	r1, sp, #8
     4d4:	2068      	movs	r0, #104	; 0x68
     4d6:	4b11      	ldr	r3, [pc, #68]	; (51c <PassData+0x78>)
     4d8:	4798      	blx	r3
		if(xQueueReceive(Global_Queue_Handle, &rx_data, 1500))
     4da:	4a11      	ldr	r2, [pc, #68]	; (520 <PassData+0x7c>)
     4dc:	4911      	ldr	r1, [pc, #68]	; (524 <PassData+0x80>)
     4de:	6830      	ldr	r0, [r6, #0]
     4e0:	47b8      	blx	r7
     4e2:	2800      	cmp	r0, #0
     4e4:	d0f9      	beq.n	4da <PassData+0x36>
			if (rx_data - '0' == 4)
     4e6:	796b      	ldrb	r3, [r5, #5]
     4e8:	2b34      	cmp	r3, #52	; 0x34
     4ea:	d0e4      	beq.n	4b6 <PassData+0x12>
				if (rx_data - '0' == 1) //Opening door requires more info
     4ec:	2b31      	cmp	r3, #49	; 0x31
     4ee:	d0e6      	beq.n	4be <PassData+0x1a>
					xQueueSend(Door_Queue_Handle, &rx_data, 2000);
     4f0:	4b08      	ldr	r3, [pc, #32]	; (514 <PassData+0x70>)
     4f2:	6818      	ldr	r0, [r3, #0]
     4f4:	2300      	movs	r3, #0
     4f6:	22fa      	movs	r2, #250	; 0xfa
     4f8:	00d2      	lsls	r2, r2, #3
     4fa:	9901      	ldr	r1, [sp, #4]
     4fc:	4c06      	ldr	r4, [pc, #24]	; (518 <PassData+0x74>)
     4fe:	47a0      	blx	r4
     500:	e7e6      	b.n	4d0 <PassData+0x2c>
     502:	46c0      	nop			; (mov r8, r8)
     504:	200042ec 	.word	0x200042ec
     508:	00000fb1 	.word	0x00000fb1
     50c:	00002578 	.word	0x00002578
     510:	000006fd 	.word	0x000006fd
     514:	20000008 	.word	0x20000008
     518:	00000d55 	.word	0x00000d55
     51c:	000013ad 	.word	0x000013ad
     520:	000005dc 	.word	0x000005dc
     524:	200042f1 	.word	0x200042f1

00000528 <main>:
		}
	}
}

int main()
{
     528:	b5f0      	push	{r4, r5, r6, r7, lr}
     52a:	b085      	sub	sp, #20
	SystemInit();
     52c:	4b32      	ldr	r3, [pc, #200]	; (5f8 <main+0xd0>)
     52e:	4798      	blx	r3
	/* Switch to 8MHz clock (disable prescaler) */
	SYSCTRL->OSC8M.bit.PRESC = 0;
     530:	4a32      	ldr	r2, [pc, #200]	; (5fc <main+0xd4>)
     532:	6a13      	ldr	r3, [r2, #32]
     534:	4932      	ldr	r1, [pc, #200]	; (600 <main+0xd8>)
     536:	400b      	ands	r3, r1
     538:	6213      	str	r3, [r2, #32]
	initUART();
     53a:	4b32      	ldr	r3, [pc, #200]	; (604 <main+0xdc>)
     53c:	4798      	blx	r3
	initI2C();
     53e:	4b32      	ldr	r3, [pc, #200]	; (608 <main+0xe0>)
     540:	4798      	blx	r3

	PORT->Group[ 0 ].PINCFG[ PIN_PA19 ].reg = 0x0; //bit PMUXEN must be clear for GPIOs
     542:	4b32      	ldr	r3, [pc, #200]	; (60c <main+0xe4>)
     544:	2100      	movs	r1, #0
     546:	2253      	movs	r2, #83	; 0x53
     548:	5499      	strb	r1, [r3, r2]
	
	PORT->Group[ 0 ].DIRSET.reg = PORT_PA19; //pin 16 declared as data output
     54a:	2280      	movs	r2, #128	; 0x80
     54c:	0312      	lsls	r2, r2, #12
     54e:	609a      	str	r2, [r3, #8]
	
	uint8_t *pointer;
	rtc_type rtc;
	pointer = (uint8_t*) &rtc;
	pointer[0] = 0x10;	//set seconds
     550:	a902      	add	r1, sp, #8
     552:	2310      	movs	r3, #16
     554:	700b      	strb	r3, [r1, #0]
	pointer[1] = 0x34;	//set minutes
     556:	3324      	adds	r3, #36	; 0x24
     558:	704b      	strb	r3, [r1, #1]
	pointer[2] = 0x18;	//set hours
     55a:	3b1c      	subs	r3, #28
     55c:	708b      	strb	r3, [r1, #2]
	pointer[4] = 0x22;	//set date
     55e:	330a      	adds	r3, #10
     560:	710b      	strb	r3, [r1, #4]
	pointer[5] = 0x04;	//set month
     562:	3b1e      	subs	r3, #30
     564:	714b      	strb	r3, [r1, #5]
	pointer[6] = 0x19;	//set year
     566:	3315      	adds	r3, #21
     568:	718b      	strb	r3, [r1, #6]

	sendI2CDataArray((uint8_t)SLAVE_ADDR, pointer, (uint8_t)7);
     56a:	2207      	movs	r2, #7
     56c:	2068      	movs	r0, #104	; 0x68
     56e:	4b28      	ldr	r3, [pc, #160]	; (610 <main+0xe8>)
     570:	4798      	blx	r3
	
	vSemaphoreCreateBinary(rx_binary_sem);
     572:	2203      	movs	r2, #3
     574:	2100      	movs	r1, #0
     576:	2001      	movs	r0, #1
     578:	4b26      	ldr	r3, [pc, #152]	; (614 <main+0xec>)
     57a:	4798      	blx	r3
     57c:	4b26      	ldr	r3, [pc, #152]	; (618 <main+0xf0>)
     57e:	6018      	str	r0, [r3, #0]
     580:	2800      	cmp	r0, #0
     582:	d004      	beq.n	58e <main+0x66>
     584:	2300      	movs	r3, #0
     586:	2200      	movs	r2, #0
     588:	2100      	movs	r1, #0
     58a:	4c24      	ldr	r4, [pc, #144]	; (61c <main+0xf4>)
     58c:	47a0      	blx	r4

	Door_Queue_Handle = xQueueCreate(1, sizeof(uint8_t));
     58e:	2200      	movs	r2, #0
     590:	2101      	movs	r1, #1
     592:	2001      	movs	r0, #1
     594:	4c1f      	ldr	r4, [pc, #124]	; (614 <main+0xec>)
     596:	47a0      	blx	r4
     598:	4b21      	ldr	r3, [pc, #132]	; (620 <main+0xf8>)
     59a:	6018      	str	r0, [r3, #0]
	Global_Queue_Handle = xQueueCreate(1, sizeof(uint8_t));
     59c:	2200      	movs	r2, #0
     59e:	2101      	movs	r1, #1
     5a0:	2001      	movs	r0, #1
     5a2:	47a0      	blx	r4
     5a4:	4b1f      	ldr	r3, [pc, #124]	; (624 <main+0xfc>)
     5a6:	6018      	str	r0, [r3, #0]
	xTaskCreate(CheckRx,"CheckRx", 512,NULL,3,NULL);
     5a8:	2580      	movs	r5, #128	; 0x80
     5aa:	00ad      	lsls	r5, r5, #2
     5ac:	2600      	movs	r6, #0
     5ae:	9601      	str	r6, [sp, #4]
     5b0:	2303      	movs	r3, #3
     5b2:	9300      	str	r3, [sp, #0]
     5b4:	2300      	movs	r3, #0
     5b6:	002a      	movs	r2, r5
     5b8:	491b      	ldr	r1, [pc, #108]	; (628 <main+0x100>)
     5ba:	481c      	ldr	r0, [pc, #112]	; (62c <main+0x104>)
     5bc:	4c1c      	ldr	r4, [pc, #112]	; (630 <main+0x108>)
     5be:	47a0      	blx	r4
	xTaskCreate(PingRasp,"PingRasp", 512, NULL, 2, NULL);
     5c0:	9601      	str	r6, [sp, #4]
     5c2:	2702      	movs	r7, #2
     5c4:	9700      	str	r7, [sp, #0]
     5c6:	2300      	movs	r3, #0
     5c8:	002a      	movs	r2, r5
     5ca:	491a      	ldr	r1, [pc, #104]	; (634 <main+0x10c>)
     5cc:	481a      	ldr	r0, [pc, #104]	; (638 <main+0x110>)
     5ce:	47a0      	blx	r4
	xTaskCreate(PassData,"PassData", 512, NULL, 2, NULL);
     5d0:	9601      	str	r6, [sp, #4]
     5d2:	9700      	str	r7, [sp, #0]
     5d4:	2300      	movs	r3, #0
     5d6:	002a      	movs	r2, r5
     5d8:	4918      	ldr	r1, [pc, #96]	; (63c <main+0x114>)
     5da:	4819      	ldr	r0, [pc, #100]	; (640 <main+0x118>)
     5dc:	47a0      	blx	r4
	xTaskCreate(HandleDoor,"HandleDoor", 512, NULL,1,NULL);
     5de:	9601      	str	r6, [sp, #4]
     5e0:	2301      	movs	r3, #1
     5e2:	9300      	str	r3, [sp, #0]
     5e4:	2300      	movs	r3, #0
     5e6:	002a      	movs	r2, r5
     5e8:	4916      	ldr	r1, [pc, #88]	; (644 <main+0x11c>)
     5ea:	4817      	ldr	r0, [pc, #92]	; (648 <main+0x120>)
     5ec:	47a0      	blx	r4

	/* Start the tasks and timer running. */
	vTaskStartScheduler();
     5ee:	4b17      	ldr	r3, [pc, #92]	; (64c <main+0x124>)
     5f0:	4798      	blx	r3
	return(0);
}
     5f2:	2000      	movs	r0, #0
     5f4:	b005      	add	sp, #20
     5f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
     5f8:	000001fd 	.word	0x000001fd
     5fc:	40000800 	.word	0x40000800
     600:	fffffcff 	.word	0xfffffcff
     604:	000021f1 	.word	0x000021f1
     608:	00001459 	.word	0x00001459
     60c:	41004400 	.word	0x41004400
     610:	0000132d 	.word	0x0000132d
     614:	00000d09 	.word	0x00000d09
     618:	2000444c 	.word	0x2000444c
     61c:	00000d55 	.word	0x00000d55
     620:	20000008 	.word	0x20000008
     624:	200042ec 	.word	0x200042ec
     628:	00002594 	.word	0x00002594
     62c:	000003ad 	.word	0x000003ad
     630:	000015f5 	.word	0x000015f5
     634:	0000259c 	.word	0x0000259c
     638:	000003ed 	.word	0x000003ed
     63c:	000025a8 	.word	0x000025a8
     640:	000004a5 	.word	0x000004a5
     644:	000025b4 	.word	0x000025b4
     648:	00000445 	.word	0x00000445
     64c:	000017c9 	.word	0x000017c9

00000650 <out>:
    //return 0;
//}


static void out(char c) {
    *bf++ = c;
     650:	4a02      	ldr	r2, [pc, #8]	; (65c <out+0xc>)
     652:	6813      	ldr	r3, [r2, #0]
     654:	1c59      	adds	r1, r3, #1
     656:	6011      	str	r1, [r2, #0]
     658:	7018      	strb	r0, [r3, #0]
    }
     65a:	4770      	bx	lr
     65c:	200042f4 	.word	0x200042f4

00000660 <outDgt>:

static void outDgt(char dgt) {
     660:	b510      	push	{r4, lr}
	out(dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10));
     662:	2330      	movs	r3, #48	; 0x30
     664:	2809      	cmp	r0, #9
     666:	d905      	bls.n	674 <outDgt+0x14>
     668:	4b06      	ldr	r3, [pc, #24]	; (684 <outDgt+0x24>)
     66a:	791a      	ldrb	r2, [r3, #4]
     66c:	2337      	movs	r3, #55	; 0x37
     66e:	2a00      	cmp	r2, #0
     670:	d100      	bne.n	674 <outDgt+0x14>
     672:	3320      	adds	r3, #32
     674:	1818      	adds	r0, r3, r0
     676:	b2c0      	uxtb	r0, r0
     678:	4b03      	ldr	r3, [pc, #12]	; (688 <outDgt+0x28>)
     67a:	4798      	blx	r3
	zs=1;
     67c:	2201      	movs	r2, #1
     67e:	4b01      	ldr	r3, [pc, #4]	; (684 <outDgt+0x24>)
     680:	715a      	strb	r2, [r3, #5]
    }
     682:	bd10      	pop	{r4, pc}
     684:	200042f4 	.word	0x200042f4
     688:	00000651 	.word	0x00000651

0000068c <divOut>:
	
static void divOut(unsigned int div) {
     68c:	b510      	push	{r4, lr}
    unsigned char dgt=0;
	num &= 0xffff; // just for testing the code  with 32 bit ints
     68e:	4b0e      	ldr	r3, [pc, #56]	; (6c8 <divOut+0x3c>)
     690:	891a      	ldrh	r2, [r3, #8]
     692:	609a      	str	r2, [r3, #8]
	while (num>=div) {
     694:	4282      	cmp	r2, r0
     696:	d310      	bcc.n	6ba <divOut+0x2e>
     698:	2300      	movs	r3, #0
		num -= div;
     69a:	1a12      	subs	r2, r2, r0
		dgt++;
     69c:	3301      	adds	r3, #1
     69e:	b2db      	uxtb	r3, r3
	while (num>=div) {
     6a0:	4290      	cmp	r0, r2
     6a2:	d9fa      	bls.n	69a <divOut+0xe>
     6a4:	4908      	ldr	r1, [pc, #32]	; (6c8 <divOut+0x3c>)
     6a6:	608a      	str	r2, [r1, #8]
		}
	if (zs || dgt>0) 
     6a8:	794a      	ldrb	r2, [r1, #5]
     6aa:	2a00      	cmp	r2, #0
     6ac:	d101      	bne.n	6b2 <divOut+0x26>
     6ae:	2b00      	cmp	r3, #0
     6b0:	d002      	beq.n	6b8 <divOut+0x2c>
		outDgt(dgt);
     6b2:	0018      	movs	r0, r3
     6b4:	4b05      	ldr	r3, [pc, #20]	; (6cc <divOut+0x40>)
     6b6:	4798      	blx	r3
    }	
     6b8:	bd10      	pop	{r4, pc}
	if (zs || dgt>0) 
     6ba:	4b03      	ldr	r3, [pc, #12]	; (6c8 <divOut+0x3c>)
     6bc:	795b      	ldrb	r3, [r3, #5]
     6be:	2b00      	cmp	r3, #0
     6c0:	d0fa      	beq.n	6b8 <divOut+0x2c>
    unsigned char dgt=0;
     6c2:	2300      	movs	r3, #0
     6c4:	e7f5      	b.n	6b2 <divOut+0x26>
     6c6:	46c0      	nop			; (mov r8, r8)
     6c8:	200042f4 	.word	0x200042f4
     6cc:	00000661 	.word	0x00000661

000006d0 <myputchar>:
  if(c=='\n')
     6d0:	280a      	cmp	r0, #10
     6d2:	d008      	beq.n	6e6 <myputchar+0x16>
  while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE));
     6d4:	4908      	ldr	r1, [pc, #32]	; (6f8 <myputchar+0x28>)
     6d6:	2201      	movs	r2, #1
     6d8:	7e0b      	ldrb	r3, [r1, #24]
     6da:	4213      	tst	r3, r2
     6dc:	d0fc      	beq.n	6d8 <myputchar+0x8>
  SERCOM0->USART.DATA.reg = s;
     6de:	b280      	uxth	r0, r0
     6e0:	4b05      	ldr	r3, [pc, #20]	; (6f8 <myputchar+0x28>)
     6e2:	8518      	strh	r0, [r3, #40]	; 0x28
}
     6e4:	4770      	bx	lr
  while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE));
     6e6:	4904      	ldr	r1, [pc, #16]	; (6f8 <myputchar+0x28>)
     6e8:	2201      	movs	r2, #1
     6ea:	7e0b      	ldrb	r3, [r1, #24]
     6ec:	4213      	tst	r3, r2
     6ee:	d0fc      	beq.n	6ea <myputchar+0x1a>
  SERCOM0->USART.DATA.reg = s;
     6f0:	220d      	movs	r2, #13
     6f2:	4b01      	ldr	r3, [pc, #4]	; (6f8 <myputchar+0x28>)
     6f4:	851a      	strh	r2, [r3, #40]	; 0x28
     6f6:	e7ed      	b.n	6d4 <myputchar+0x4>
     6f8:	42000800 	.word	0x42000800

000006fc <tfp_printf>:

void tfp_printf(char *fmt, ...)
	{
     6fc:	b40f      	push	{r0, r1, r2, r3}
     6fe:	b5f0      	push	{r4, r5, r6, r7, lr}
     700:	46de      	mov	lr, fp
     702:	4657      	mov	r7, sl
     704:	464e      	mov	r6, r9
     706:	4645      	mov	r5, r8
     708:	b5e0      	push	{r5, r6, r7, lr}
     70a:	b087      	sub	sp, #28
     70c:	ab10      	add	r3, sp, #64	; 0x40
     70e:	cb80      	ldmia	r3!, {r7}
	va_list va;
	char ch;
	char* p;
	
	va_start(va,fmt);
     710:	9305      	str	r3, [sp, #20]
				while (ch>='0' && ch<='9') {
					w=(((w<<2)+w)<<1)+ch-'0';
					ch=*fmt++;
					}
				}
			bf=buf;
     712:	4b73      	ldr	r3, [pc, #460]	; (8e0 <tfp_printf+0x1e4>)
     714:	330c      	adds	r3, #12
     716:	9302      	str	r3, [sp, #8]
				case '%' :
					out('%');
				default:
					break;
				}
			*bf=0;
     718:	4b71      	ldr	r3, [pc, #452]	; (8e0 <tfp_printf+0x1e4>)
     71a:	469a      	mov	sl, r3
			while (*bf++ && w > 0)
				w--;
			while (w-- > 0) 
				myputchar(lz ? '0' : ' ');
			while ((ch= *p++))
				myputchar(ch);
     71c:	4b71      	ldr	r3, [pc, #452]	; (8e4 <tfp_printf+0x1e8>)
     71e:	4698      	mov	r8, r3
			p=bf;
     720:	4653      	mov	r3, sl
     722:	330c      	adds	r3, #12
     724:	9303      	str	r3, [sp, #12]
	while ((ch=*(fmt++))) {
     726:	e08c      	b.n	842 <tfp_printf+0x146>
			ch=*(fmt++);
     728:	787b      	ldrb	r3, [r7, #1]
			if (ch=='0') {
     72a:	2b30      	cmp	r3, #48	; 0x30
     72c:	d029      	beq.n	782 <tfp_printf+0x86>
			ch=*(fmt++);
     72e:	3702      	adds	r7, #2
			char lz=0;
     730:	2200      	movs	r2, #0
     732:	4693      	mov	fp, r2
			char w=0;
     734:	2400      	movs	r4, #0
			if (ch>='0' && ch<='9') {
     736:	001a      	movs	r2, r3
     738:	3a30      	subs	r2, #48	; 0x30
     73a:	2a09      	cmp	r2, #9
     73c:	d80c      	bhi.n	758 <tfp_printf+0x5c>
					w=(((w<<2)+w)<<1)+ch-'0';
     73e:	00a2      	lsls	r2, r4, #2
     740:	18a4      	adds	r4, r4, r2
     742:	0064      	lsls	r4, r4, #1
     744:	3c30      	subs	r4, #48	; 0x30
     746:	18e4      	adds	r4, r4, r3
     748:	b2e4      	uxtb	r4, r4
					ch=*fmt++;
     74a:	1c7a      	adds	r2, r7, #1
     74c:	783b      	ldrb	r3, [r7, #0]
     74e:	0017      	movs	r7, r2
				while (ch>='0' && ch<='9') {
     750:	0019      	movs	r1, r3
     752:	3930      	subs	r1, #48	; 0x30
     754:	2909      	cmp	r1, #9
     756:	d9f2      	bls.n	73e <tfp_printf+0x42>
			bf=buf;
     758:	4a61      	ldr	r2, [pc, #388]	; (8e0 <tfp_printf+0x1e4>)
     75a:	9902      	ldr	r1, [sp, #8]
     75c:	6011      	str	r1, [r2, #0]
			zs=0;
     75e:	2200      	movs	r2, #0
     760:	495f      	ldr	r1, [pc, #380]	; (8e0 <tfp_printf+0x1e4>)
     762:	714a      	strb	r2, [r1, #5]
			switch (ch) {
     764:	2b63      	cmp	r3, #99	; 0x63
     766:	d100      	bne.n	76a <tfp_printf+0x6e>
     768:	e07d      	b.n	866 <tfp_printf+0x16a>
     76a:	d80f      	bhi.n	78c <tfp_printf+0x90>
     76c:	2b25      	cmp	r3, #37	; 0x25
     76e:	d100      	bne.n	772 <tfp_printf+0x76>
     770:	e086      	b.n	880 <tfp_printf+0x184>
     772:	2b58      	cmp	r3, #88	; 0x58
     774:	d011      	beq.n	79a <tfp_printf+0x9e>
     776:	2b00      	cmp	r3, #0
     778:	d100      	bne.n	77c <tfp_printf+0x80>
     77a:	e0a6      	b.n	8ca <tfp_printf+0x1ce>
			p=bf;
     77c:	4d58      	ldr	r5, [pc, #352]	; (8e0 <tfp_printf+0x1e4>)
     77e:	350c      	adds	r5, #12
     780:	e03c      	b.n	7fc <tfp_printf+0x100>
				ch=*(fmt++);
     782:	78bb      	ldrb	r3, [r7, #2]
     784:	3703      	adds	r7, #3
				lz=1;
     786:	2201      	movs	r2, #1
     788:	4693      	mov	fp, r2
     78a:	e7d3      	b.n	734 <tfp_printf+0x38>
			switch (ch) {
     78c:	2b73      	cmp	r3, #115	; 0x73
     78e:	d072      	beq.n	876 <tfp_printf+0x17a>
     790:	d91b      	bls.n	7ca <tfp_printf+0xce>
     792:	2b75      	cmp	r3, #117	; 0x75
     794:	d01b      	beq.n	7ce <tfp_printf+0xd2>
     796:	2b78      	cmp	r3, #120	; 0x78
     798:	d1f0      	bne.n	77c <tfp_printf+0x80>
				    uc= ch=='X';
     79a:	4d51      	ldr	r5, [pc, #324]	; (8e0 <tfp_printf+0x1e4>)
     79c:	3b58      	subs	r3, #88	; 0x58
     79e:	4259      	negs	r1, r3
     7a0:	4159      	adcs	r1, r3
     7a2:	7129      	strb	r1, [r5, #4]
					num=va_arg(va, unsigned int);
     7a4:	9b05      	ldr	r3, [sp, #20]
     7a6:	1d1a      	adds	r2, r3, #4
     7a8:	9205      	str	r2, [sp, #20]
     7aa:	681b      	ldr	r3, [r3, #0]
     7ac:	60ab      	str	r3, [r5, #8]
					divOut(0x1000);
     7ae:	2080      	movs	r0, #128	; 0x80
     7b0:	0140      	lsls	r0, r0, #5
     7b2:	4e4d      	ldr	r6, [pc, #308]	; (8e8 <tfp_printf+0x1ec>)
     7b4:	47b0      	blx	r6
					divOut(0x100);
     7b6:	2080      	movs	r0, #128	; 0x80
     7b8:	0040      	lsls	r0, r0, #1
     7ba:	47b0      	blx	r6
					divOut(0x10);
     7bc:	2010      	movs	r0, #16
     7be:	47b0      	blx	r6
					outDgt(num);
     7c0:	7a28      	ldrb	r0, [r5, #8]
     7c2:	4b4a      	ldr	r3, [pc, #296]	; (8ec <tfp_printf+0x1f0>)
     7c4:	4798      	blx	r3
			p=bf;
     7c6:	350c      	adds	r5, #12
					break;
     7c8:	e018      	b.n	7fc <tfp_printf+0x100>
			switch (ch) {
     7ca:	2b64      	cmp	r3, #100	; 0x64
     7cc:	d1d6      	bne.n	77c <tfp_printf+0x80>
					num=va_arg(va, unsigned int);
     7ce:	9a05      	ldr	r2, [sp, #20]
     7d0:	1d11      	adds	r1, r2, #4
     7d2:	9105      	str	r1, [sp, #20]
     7d4:	6812      	ldr	r2, [r2, #0]
     7d6:	4942      	ldr	r1, [pc, #264]	; (8e0 <tfp_printf+0x1e4>)
     7d8:	608a      	str	r2, [r1, #8]
					if (ch=='d' && (int)num<0) {
     7da:	2b64      	cmp	r3, #100	; 0x64
     7dc:	d03b      	beq.n	856 <tfp_printf+0x15a>
					divOut(10000);
     7de:	4844      	ldr	r0, [pc, #272]	; (8f0 <tfp_printf+0x1f4>)
     7e0:	4d41      	ldr	r5, [pc, #260]	; (8e8 <tfp_printf+0x1ec>)
     7e2:	47a8      	blx	r5
					divOut(1000);
     7e4:	20fa      	movs	r0, #250	; 0xfa
     7e6:	0080      	lsls	r0, r0, #2
     7e8:	47a8      	blx	r5
					divOut(100);
     7ea:	2064      	movs	r0, #100	; 0x64
     7ec:	47a8      	blx	r5
					divOut(10);
     7ee:	200a      	movs	r0, #10
     7f0:	47a8      	blx	r5
					outDgt(num);
     7f2:	4d3b      	ldr	r5, [pc, #236]	; (8e0 <tfp_printf+0x1e4>)
     7f4:	7a28      	ldrb	r0, [r5, #8]
     7f6:	4b3d      	ldr	r3, [pc, #244]	; (8ec <tfp_printf+0x1f0>)
     7f8:	4798      	blx	r3
			p=bf;
     7fa:	350c      	adds	r5, #12
			*bf=0;
     7fc:	2300      	movs	r3, #0
     7fe:	4652      	mov	r2, sl
     800:	6812      	ldr	r2, [r2, #0]
     802:	7013      	strb	r3, [r2, #0]
			while (*bf++ && w > 0)
     804:	1c6b      	adds	r3, r5, #1
     806:	4699      	mov	r9, r3
     808:	4653      	mov	r3, sl
     80a:	464a      	mov	r2, r9
     80c:	601a      	str	r2, [r3, #0]
     80e:	7828      	ldrb	r0, [r5, #0]
     810:	2800      	cmp	r0, #0
     812:	d055      	beq.n	8c0 <tfp_printf+0x1c4>
     814:	2c00      	cmp	r4, #0
     816:	d00c      	beq.n	832 <tfp_printf+0x136>
     818:	1caa      	adds	r2, r5, #2
				w--;
     81a:	1e63      	subs	r3, r4, #1
     81c:	b2db      	uxtb	r3, r3
			while (*bf++ && w > 0)
     81e:	0011      	movs	r1, r2
     820:	1e56      	subs	r6, r2, #1
     822:	7836      	ldrb	r6, [r6, #0]
     824:	2e00      	cmp	r6, #0
     826:	d03c      	beq.n	8a2 <tfp_printf+0x1a6>
     828:	3201      	adds	r2, #1
				w--;
     82a:	1e1c      	subs	r4, r3, #0
			while (*bf++ && w > 0)
     82c:	d1f5      	bne.n	81a <tfp_printf+0x11e>
     82e:	4b2c      	ldr	r3, [pc, #176]	; (8e0 <tfp_printf+0x1e4>)
     830:	6019      	str	r1, [r3, #0]
			while ((ch= *p++))
     832:	7828      	ldrb	r0, [r5, #0]
     834:	464d      	mov	r5, r9
				myputchar(ch);
     836:	47c0      	blx	r8
     838:	3501      	adds	r5, #1
			while ((ch= *p++))
     83a:	1e6b      	subs	r3, r5, #1
     83c:	7818      	ldrb	r0, [r3, #0]
     83e:	2800      	cmp	r0, #0
     840:	d1f9      	bne.n	836 <tfp_printf+0x13a>
	while ((ch=*(fmt++))) {
     842:	7838      	ldrb	r0, [r7, #0]
     844:	2800      	cmp	r0, #0
     846:	d040      	beq.n	8ca <tfp_printf+0x1ce>
		if (ch!='%') {
     848:	2825      	cmp	r0, #37	; 0x25
     84a:	d100      	bne.n	84e <tfp_printf+0x152>
     84c:	e76c      	b.n	728 <tfp_printf+0x2c>
	while ((ch=*(fmt++))) {
     84e:	3701      	adds	r7, #1
			myputchar(ch);
     850:	4b24      	ldr	r3, [pc, #144]	; (8e4 <tfp_printf+0x1e8>)
     852:	4798      	blx	r3
     854:	e7f5      	b.n	842 <tfp_printf+0x146>
					if (ch=='d' && (int)num<0) {
     856:	2a00      	cmp	r2, #0
     858:	dac1      	bge.n	7de <tfp_printf+0xe2>
						num = -(int)num;
     85a:	4252      	negs	r2, r2
     85c:	608a      	str	r2, [r1, #8]
						out('-');
     85e:	202d      	movs	r0, #45	; 0x2d
     860:	4b24      	ldr	r3, [pc, #144]	; (8f4 <tfp_printf+0x1f8>)
     862:	4798      	blx	r3
     864:	e7bb      	b.n	7de <tfp_printf+0xe2>
					out((char)(va_arg(va, int)));
     866:	9b05      	ldr	r3, [sp, #20]
     868:	1d1a      	adds	r2, r3, #4
     86a:	9205      	str	r2, [sp, #20]
     86c:	7818      	ldrb	r0, [r3, #0]
     86e:	4b21      	ldr	r3, [pc, #132]	; (8f4 <tfp_printf+0x1f8>)
     870:	4798      	blx	r3
			p=bf;
     872:	9d03      	ldr	r5, [sp, #12]
					break;
     874:	e7c2      	b.n	7fc <tfp_printf+0x100>
					p=va_arg(va, char*);
     876:	9b05      	ldr	r3, [sp, #20]
     878:	1d1a      	adds	r2, r3, #4
     87a:	9205      	str	r2, [sp, #20]
     87c:	681d      	ldr	r5, [r3, #0]
					break;
     87e:	e7bd      	b.n	7fc <tfp_printf+0x100>
					out('%');
     880:	2025      	movs	r0, #37	; 0x25
     882:	4b1c      	ldr	r3, [pc, #112]	; (8f4 <tfp_printf+0x1f8>)
     884:	4798      	blx	r3
			p=bf;
     886:	4d16      	ldr	r5, [pc, #88]	; (8e0 <tfp_printf+0x1e4>)
     888:	350c      	adds	r5, #12
     88a:	e7b7      	b.n	7fc <tfp_printf+0x100>
			while (w-- > 0) 
     88c:	001e      	movs	r6, r3
				myputchar(lz ? '0' : ' ');
     88e:	9801      	ldr	r0, [sp, #4]
     890:	47a0      	blx	r4
			while (w-- > 0) 
     892:	1e73      	subs	r3, r6, #1
     894:	b2db      	uxtb	r3, r3
     896:	2e00      	cmp	r6, #0
     898:	d1f8      	bne.n	88c <tfp_printf+0x190>
			while ((ch= *p++))
     89a:	7828      	ldrb	r0, [r5, #0]
     89c:	2800      	cmp	r0, #0
     89e:	d1c9      	bne.n	834 <tfp_printf+0x138>
     8a0:	e7cf      	b.n	842 <tfp_printf+0x146>
     8a2:	4a0f      	ldr	r2, [pc, #60]	; (8e0 <tfp_printf+0x1e4>)
     8a4:	6011      	str	r1, [r2, #0]
			while (w-- > 0) 
     8a6:	3c02      	subs	r4, #2
     8a8:	b2e6      	uxtb	r6, r4
     8aa:	2b00      	cmp	r3, #0
     8ac:	d0c2      	beq.n	834 <tfp_printf+0x138>
     8ae:	2420      	movs	r4, #32
     8b0:	465b      	mov	r3, fp
     8b2:	2b00      	cmp	r3, #0
     8b4:	d000      	beq.n	8b8 <tfp_printf+0x1bc>
     8b6:	2430      	movs	r4, #48	; 0x30
     8b8:	b2e3      	uxtb	r3, r4
     8ba:	9301      	str	r3, [sp, #4]
				myputchar(lz ? '0' : ' ');
     8bc:	4c09      	ldr	r4, [pc, #36]	; (8e4 <tfp_printf+0x1e8>)
     8be:	e7e6      	b.n	88e <tfp_printf+0x192>
			while (w-- > 0) 
     8c0:	1e66      	subs	r6, r4, #1
     8c2:	b2f6      	uxtb	r6, r6
     8c4:	2c00      	cmp	r4, #0
     8c6:	d1f2      	bne.n	8ae <tfp_printf+0x1b2>
     8c8:	e7bb      	b.n	842 <tfp_printf+0x146>
			}
		}
	abort:;
	va_end(va);
	}
     8ca:	b007      	add	sp, #28
     8cc:	bc3c      	pop	{r2, r3, r4, r5}
     8ce:	4690      	mov	r8, r2
     8d0:	4699      	mov	r9, r3
     8d2:	46a2      	mov	sl, r4
     8d4:	46ab      	mov	fp, r5
     8d6:	bcf0      	pop	{r4, r5, r6, r7}
     8d8:	bc08      	pop	{r3}
     8da:	b004      	add	sp, #16
     8dc:	4718      	bx	r3
     8de:	46c0      	nop			; (mov r8, r8)
     8e0:	200042f4 	.word	0x200042f4
     8e4:	000006d1 	.word	0x000006d1
     8e8:	0000068d 	.word	0x0000068d
     8ec:	00000661 	.word	0x00000661
     8f0:	00002710 	.word	0x00002710
     8f4:	00000651 	.word	0x00000651

000008f8 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
     8f8:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
     8fa:	2300      	movs	r3, #0
     8fc:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
     8fe:	4b06      	ldr	r3, [pc, #24]	; (918 <prvTaskExitError+0x20>)
     900:	681b      	ldr	r3, [r3, #0]
     902:	3301      	adds	r3, #1
     904:	d001      	beq.n	90a <prvTaskExitError+0x12>
     906:	b672      	cpsid	i
     908:	e7fe      	b.n	908 <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
     90a:	b672      	cpsid	i
	while( ulDummy == 0 )
     90c:	9b01      	ldr	r3, [sp, #4]
     90e:	2b00      	cmp	r3, #0
     910:	d0fc      	beq.n	90c <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
     912:	b002      	add	sp, #8
     914:	4770      	bx	lr
     916:	46c0      	nop			; (mov r8, r8)
     918:	2000000c 	.word	0x2000000c
     91c:	00000000 	.word	0x00000000

00000920 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
     920:	4a0b      	ldr	r2, [pc, #44]	; (950 <pxCurrentTCBConst2>)
     922:	6813      	ldr	r3, [r2, #0]
     924:	6818      	ldr	r0, [r3, #0]
     926:	3020      	adds	r0, #32
     928:	f380 8809 	msr	PSP, r0
     92c:	2002      	movs	r0, #2
     92e:	f380 8814 	msr	CONTROL, r0
     932:	f3bf 8f6f 	isb	sy
     936:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
     938:	46ae      	mov	lr, r5
     93a:	bc08      	pop	{r3}
     93c:	bc04      	pop	{r2}
     93e:	b662      	cpsie	i
     940:	4718      	bx	r3
     942:	46c0      	nop			; (mov r8, r8)
     944:	46c0      	nop			; (mov r8, r8)
     946:	46c0      	nop			; (mov r8, r8)
     948:	46c0      	nop			; (mov r8, r8)
     94a:	46c0      	nop			; (mov r8, r8)
     94c:	46c0      	nop			; (mov r8, r8)
     94e:	46c0      	nop			; (mov r8, r8)

00000950 <pxCurrentTCBConst2>:
     950:	200043c0 	.word	0x200043c0

00000954 <pxPortInitialiseStack>:
{
     954:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
     956:	1f03      	subs	r3, r0, #4
     958:	2480      	movs	r4, #128	; 0x80
     95a:	0464      	lsls	r4, r4, #17
     95c:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
     95e:	3b04      	subs	r3, #4
     960:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
     962:	3b04      	subs	r3, #4
     964:	4902      	ldr	r1, [pc, #8]	; (970 <pxPortInitialiseStack+0x1c>)
     966:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
     968:	3b14      	subs	r3, #20
     96a:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
     96c:	3840      	subs	r0, #64	; 0x40
}
     96e:	bd10      	pop	{r4, pc}
     970:	000008f9 	.word	0x000008f9

00000974 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
     974:	b510      	push	{r4, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
     976:	4b0f      	ldr	r3, [pc, #60]	; (9b4 <xPortStartScheduler+0x40>)
     978:	6819      	ldr	r1, [r3, #0]
     97a:	22ff      	movs	r2, #255	; 0xff
     97c:	0412      	lsls	r2, r2, #16
     97e:	430a      	orrs	r2, r1
     980:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
     982:	6819      	ldr	r1, [r3, #0]
     984:	22ff      	movs	r2, #255	; 0xff
     986:	0612      	lsls	r2, r2, #24
     988:	430a      	orrs	r2, r1
     98a:	601a      	str	r2, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL) = 0UL;
     98c:	4a0a      	ldr	r2, [pc, #40]	; (9b8 <xPortStartScheduler+0x44>)
     98e:	2300      	movs	r3, #0
     990:	6013      	str	r3, [r2, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
     992:	490a      	ldr	r1, [pc, #40]	; (9bc <xPortStartScheduler+0x48>)
     994:	600b      	str	r3, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
     996:	480a      	ldr	r0, [pc, #40]	; (9c0 <xPortStartScheduler+0x4c>)
     998:	490a      	ldr	r1, [pc, #40]	; (9c4 <xPortStartScheduler+0x50>)
     99a:	6008      	str	r0, [r1, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
     99c:	2107      	movs	r1, #7
     99e:	6011      	str	r1, [r2, #0]
	uxCriticalNesting = 0;
     9a0:	4a09      	ldr	r2, [pc, #36]	; (9c8 <xPortStartScheduler+0x54>)
     9a2:	6013      	str	r3, [r2, #0]
	vPortStartFirstTask();
     9a4:	4b09      	ldr	r3, [pc, #36]	; (9cc <xPortStartScheduler+0x58>)
     9a6:	4798      	blx	r3
	vTaskSwitchContext();
     9a8:	4b09      	ldr	r3, [pc, #36]	; (9d0 <xPortStartScheduler+0x5c>)
     9aa:	4798      	blx	r3
	prvTaskExitError();
     9ac:	4b09      	ldr	r3, [pc, #36]	; (9d4 <xPortStartScheduler+0x60>)
     9ae:	4798      	blx	r3
}
     9b0:	2000      	movs	r0, #0
     9b2:	bd10      	pop	{r4, pc}
     9b4:	e000ed20 	.word	0xe000ed20
     9b8:	e000e010 	.word	0xe000e010
     9bc:	e000e018 	.word	0xe000e018
     9c0:	000176ff 	.word	0x000176ff
     9c4:	e000e014 	.word	0xe000e014
     9c8:	2000000c 	.word	0x2000000c
     9cc:	00000921 	.word	0x00000921
     9d0:	00001a91 	.word	0x00001a91
     9d4:	000008f9 	.word	0x000008f9

000009d8 <vPortYield>:
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
     9d8:	2280      	movs	r2, #128	; 0x80
     9da:	0552      	lsls	r2, r2, #21
     9dc:	4b03      	ldr	r3, [pc, #12]	; (9ec <vPortYield+0x14>)
     9de:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
     9e0:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     9e4:	f3bf 8f6f 	isb	sy
}
     9e8:	4770      	bx	lr
     9ea:	46c0      	nop			; (mov r8, r8)
     9ec:	e000ed04 	.word	0xe000ed04

000009f0 <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
     9f0:	b672      	cpsid	i
    uxCriticalNesting++;
     9f2:	4a04      	ldr	r2, [pc, #16]	; (a04 <vPortEnterCritical+0x14>)
     9f4:	6813      	ldr	r3, [r2, #0]
     9f6:	3301      	adds	r3, #1
     9f8:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" ::: "memory" );
     9fa:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     9fe:	f3bf 8f6f 	isb	sy
}
     a02:	4770      	bx	lr
     a04:	2000000c 	.word	0x2000000c

00000a08 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
     a08:	4b06      	ldr	r3, [pc, #24]	; (a24 <vPortExitCritical+0x1c>)
     a0a:	681b      	ldr	r3, [r3, #0]
     a0c:	2b00      	cmp	r3, #0
     a0e:	d101      	bne.n	a14 <vPortExitCritical+0xc>
     a10:	b672      	cpsid	i
     a12:	e7fe      	b.n	a12 <vPortExitCritical+0xa>
    uxCriticalNesting--;
     a14:	3b01      	subs	r3, #1
     a16:	4a03      	ldr	r2, [pc, #12]	; (a24 <vPortExitCritical+0x1c>)
     a18:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
     a1a:	2b00      	cmp	r3, #0
     a1c:	d100      	bne.n	a20 <vPortExitCritical+0x18>
        portENABLE_INTERRUPTS();
     a1e:	b662      	cpsie	i
}
     a20:	4770      	bx	lr
     a22:	46c0      	nop			; (mov r8, r8)
     a24:	2000000c 	.word	0x2000000c

00000a28 <ulSetInterruptMaskFromISR>:
	__asm volatile(
     a28:	f3ef 8010 	mrs	r0, PRIMASK
     a2c:	b672      	cpsid	i
     a2e:	4770      	bx	lr

00000a30 <vClearInterruptMaskFromISR>:
	__asm volatile(
     a30:	f380 8810 	msr	PRIMASK, r0
     a34:	4770      	bx	lr
	...

00000a40 <PendSV_Handler>:
	__asm volatile
     a40:	f3ef 8009 	mrs	r0, PSP
     a44:	4b0e      	ldr	r3, [pc, #56]	; (a80 <pxCurrentTCBConst>)
     a46:	681a      	ldr	r2, [r3, #0]
     a48:	3820      	subs	r0, #32
     a4a:	6010      	str	r0, [r2, #0]
     a4c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     a4e:	4644      	mov	r4, r8
     a50:	464d      	mov	r5, r9
     a52:	4656      	mov	r6, sl
     a54:	465f      	mov	r7, fp
     a56:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     a58:	b508      	push	{r3, lr}
     a5a:	b672      	cpsid	i
     a5c:	f001 f818 	bl	1a90 <vTaskSwitchContext>
     a60:	b662      	cpsie	i
     a62:	bc0c      	pop	{r2, r3}
     a64:	6811      	ldr	r1, [r2, #0]
     a66:	6808      	ldr	r0, [r1, #0]
     a68:	3010      	adds	r0, #16
     a6a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     a6c:	46a0      	mov	r8, r4
     a6e:	46a9      	mov	r9, r5
     a70:	46b2      	mov	sl, r6
     a72:	46bb      	mov	fp, r7
     a74:	f380 8809 	msr	PSP, r0
     a78:	3820      	subs	r0, #32
     a7a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     a7c:	4718      	bx	r3
     a7e:	46c0      	nop			; (mov r8, r8)

00000a80 <pxCurrentTCBConst>:
     a80:	200043c0 	.word	0x200043c0

00000a84 <SysTick_Handler>:
{
     a84:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
     a86:	4b07      	ldr	r3, [pc, #28]	; (aa4 <SysTick_Handler+0x20>)
     a88:	4798      	blx	r3
     a8a:	0004      	movs	r4, r0
		if( xTaskIncrementTick() != pdFALSE )
     a8c:	4b06      	ldr	r3, [pc, #24]	; (aa8 <SysTick_Handler+0x24>)
     a8e:	4798      	blx	r3
     a90:	2800      	cmp	r0, #0
     a92:	d003      	beq.n	a9c <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     a94:	2280      	movs	r2, #128	; 0x80
     a96:	0552      	lsls	r2, r2, #21
     a98:	4b04      	ldr	r3, [pc, #16]	; (aac <SysTick_Handler+0x28>)
     a9a:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
     a9c:	0020      	movs	r0, r4
     a9e:	4b04      	ldr	r3, [pc, #16]	; (ab0 <SysTick_Handler+0x2c>)
     aa0:	4798      	blx	r3
}
     aa2:	bd10      	pop	{r4, pc}
     aa4:	00000a29 	.word	0x00000a29
     aa8:	0000184d 	.word	0x0000184d
     aac:	e000ed04 	.word	0xe000ed04
     ab0:	00000a31 	.word	0x00000a31

00000ab4 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
     ab4:	b510      	push	{r4, lr}
     ab6:	0004      	movs	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
     ab8:	4b03      	ldr	r3, [pc, #12]	; (ac8 <prvIsQueueEmpty+0x14>)
     aba:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     abc:	6ba4      	ldr	r4, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     abe:	4b03      	ldr	r3, [pc, #12]	; (acc <prvIsQueueEmpty+0x18>)
     ac0:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     ac2:	4260      	negs	r0, r4
     ac4:	4160      	adcs	r0, r4

	return xReturn;
}
     ac6:	bd10      	pop	{r4, pc}
     ac8:	000009f1 	.word	0x000009f1
     acc:	00000a09 	.word	0x00000a09

00000ad0 <prvCopyDataToQueue>:
{
     ad0:	b570      	push	{r4, r5, r6, lr}
     ad2:	0004      	movs	r4, r0
     ad4:	0016      	movs	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     ad6:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     ad8:	6c02      	ldr	r2, [r0, #64]	; 0x40
     ada:	2a00      	cmp	r2, #0
     adc:	d10b      	bne.n	af6 <prvCopyDataToQueue+0x26>
BaseType_t xReturn = pdFALSE;
     ade:	2000      	movs	r0, #0
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     ae0:	6823      	ldr	r3, [r4, #0]
     ae2:	4283      	cmp	r3, r0
     ae4:	d104      	bne.n	af0 <prvCopyDataToQueue+0x20>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     ae6:	6860      	ldr	r0, [r4, #4]
     ae8:	4b16      	ldr	r3, [pc, #88]	; (b44 <prvCopyDataToQueue+0x74>)
     aea:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     aec:	2300      	movs	r3, #0
     aee:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
     af0:	3501      	adds	r5, #1
     af2:	63a5      	str	r5, [r4, #56]	; 0x38
}
     af4:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
     af6:	2e00      	cmp	r6, #0
     af8:	d10e      	bne.n	b18 <prvCopyDataToQueue+0x48>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     afa:	6880      	ldr	r0, [r0, #8]
     afc:	4b12      	ldr	r3, [pc, #72]	; (b48 <prvCopyDataToQueue+0x78>)
     afe:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     b00:	68a3      	ldr	r3, [r4, #8]
     b02:	6c22      	ldr	r2, [r4, #64]	; 0x40
     b04:	4694      	mov	ip, r2
     b06:	4463      	add	r3, ip
     b08:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
     b0a:	2000      	movs	r0, #0
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     b0c:	6862      	ldr	r2, [r4, #4]
     b0e:	4293      	cmp	r3, r2
     b10:	d3ee      	bcc.n	af0 <prvCopyDataToQueue+0x20>
			pxQueue->pcWriteTo = pxQueue->pcHead;
     b12:	6823      	ldr	r3, [r4, #0]
     b14:	60a3      	str	r3, [r4, #8]
     b16:	e7eb      	b.n	af0 <prvCopyDataToQueue+0x20>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b18:	68c0      	ldr	r0, [r0, #12]
     b1a:	4b0b      	ldr	r3, [pc, #44]	; (b48 <prvCopyDataToQueue+0x78>)
     b1c:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     b1e:	6c23      	ldr	r3, [r4, #64]	; 0x40
     b20:	425b      	negs	r3, r3
     b22:	68e2      	ldr	r2, [r4, #12]
     b24:	18d2      	adds	r2, r2, r3
     b26:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     b28:	6821      	ldr	r1, [r4, #0]
     b2a:	428a      	cmp	r2, r1
     b2c:	d203      	bcs.n	b36 <prvCopyDataToQueue+0x66>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     b2e:	6862      	ldr	r2, [r4, #4]
     b30:	4694      	mov	ip, r2
     b32:	4463      	add	r3, ip
     b34:	60e3      	str	r3, [r4, #12]
BaseType_t xReturn = pdFALSE;
     b36:	2000      	movs	r0, #0
		if( xPosition == queueOVERWRITE )
     b38:	2e02      	cmp	r6, #2
     b3a:	d1d9      	bne.n	af0 <prvCopyDataToQueue+0x20>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     b3c:	4285      	cmp	r5, r0
     b3e:	d0d7      	beq.n	af0 <prvCopyDataToQueue+0x20>
				--uxMessagesWaiting;
     b40:	3d01      	subs	r5, #1
     b42:	e7d5      	b.n	af0 <prvCopyDataToQueue+0x20>
     b44:	00001d45 	.word	0x00001d45
     b48:	000022d5 	.word	0x000022d5

00000b4c <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
     b4c:	b570      	push	{r4, r5, r6, lr}
     b4e:	b082      	sub	sp, #8
     b50:	9001      	str	r0, [sp, #4]
     b52:	000a      	movs	r2, r1
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     b54:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
     b56:	2c00      	cmp	r4, #0
     b58:	d005      	beq.n	b66 <prvNotifyQueueSetContainer+0x1a>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
     b5a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     b5c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     b5e:	4299      	cmp	r1, r3
     b60:	d303      	bcc.n	b6a <prvNotifyQueueSetContainer+0x1e>
     b62:	b672      	cpsid	i
     b64:	e7fe      	b.n	b64 <prvNotifyQueueSetContainer+0x18>
		configASSERT( pxQueueSetContainer );
     b66:	b672      	cpsid	i
     b68:	e7fe      	b.n	b68 <prvNotifyQueueSetContainer+0x1c>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
     b6a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
	BaseType_t xReturn = pdFALSE;
     b6c:	2600      	movs	r6, #0
		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
     b6e:	428b      	cmp	r3, r1
     b70:	d802      	bhi.n	b78 <prvNotifyQueueSetContainer+0x2c>
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     b72:	0030      	movs	r0, r6
     b74:	b002      	add	sp, #8
     b76:	bd70      	pop	{r4, r5, r6, pc}
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
     b78:	2345      	movs	r3, #69	; 0x45
     b7a:	5ce5      	ldrb	r5, [r4, r3]
     b7c:	b26d      	sxtb	r5, r5
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
     b7e:	a901      	add	r1, sp, #4
     b80:	0020      	movs	r0, r4
     b82:	4b0a      	ldr	r3, [pc, #40]	; (bac <prvNotifyQueueSetContainer+0x60>)
     b84:	4798      	blx	r3
     b86:	0006      	movs	r6, r0
			if( cTxLock == queueUNLOCKED )
     b88:	1c6b      	adds	r3, r5, #1
     b8a:	d10a      	bne.n	ba2 <prvNotifyQueueSetContainer+0x56>
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
     b8c:	6a63      	ldr	r3, [r4, #36]	; 0x24
     b8e:	2b00      	cmp	r3, #0
     b90:	d0ef      	beq.n	b72 <prvNotifyQueueSetContainer+0x26>
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
     b92:	0020      	movs	r0, r4
     b94:	3024      	adds	r0, #36	; 0x24
     b96:	4b06      	ldr	r3, [pc, #24]	; (bb0 <prvNotifyQueueSetContainer+0x64>)
     b98:	4798      	blx	r3
     b9a:	2800      	cmp	r0, #0
     b9c:	d0e9      	beq.n	b72 <prvNotifyQueueSetContainer+0x26>
						xReturn = pdTRUE;
     b9e:	2601      	movs	r6, #1
     ba0:	e7e7      	b.n	b72 <prvNotifyQueueSetContainer+0x26>
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
     ba2:	3501      	adds	r5, #1
     ba4:	b26d      	sxtb	r5, r5
     ba6:	2345      	movs	r3, #69	; 0x45
     ba8:	54e5      	strb	r5, [r4, r3]
     baa:	e7e2      	b.n	b72 <prvNotifyQueueSetContainer+0x26>
     bac:	00000ad1 	.word	0x00000ad1
     bb0:	00001b89 	.word	0x00001b89

00000bb4 <prvCopyDataFromQueue>:
{
     bb4:	b510      	push	{r4, lr}
     bb6:	000c      	movs	r4, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     bb8:	6c02      	ldr	r2, [r0, #64]	; 0x40
     bba:	2a00      	cmp	r2, #0
     bbc:	d00b      	beq.n	bd6 <prvCopyDataFromQueue+0x22>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     bbe:	68c3      	ldr	r3, [r0, #12]
     bc0:	189b      	adds	r3, r3, r2
     bc2:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     bc4:	6841      	ldr	r1, [r0, #4]
     bc6:	428b      	cmp	r3, r1
     bc8:	d301      	bcc.n	bce <prvCopyDataFromQueue+0x1a>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     bca:	6803      	ldr	r3, [r0, #0]
     bcc:	60c3      	str	r3, [r0, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     bce:	68c1      	ldr	r1, [r0, #12]
     bd0:	0020      	movs	r0, r4
     bd2:	4b01      	ldr	r3, [pc, #4]	; (bd8 <prvCopyDataFromQueue+0x24>)
     bd4:	4798      	blx	r3
}
     bd6:	bd10      	pop	{r4, pc}
     bd8:	000022d5 	.word	0x000022d5

00000bdc <prvUnlockQueue>:
{
     bdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     bde:	0007      	movs	r7, r0
	taskENTER_CRITICAL();
     be0:	4b25      	ldr	r3, [pc, #148]	; (c78 <prvUnlockQueue+0x9c>)
     be2:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
     be4:	2345      	movs	r3, #69	; 0x45
     be6:	5cfc      	ldrb	r4, [r7, r3]
     be8:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     bea:	2c00      	cmp	r4, #0
     bec:	dd1c      	ble.n	c28 <prvUnlockQueue+0x4c>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
     bee:	4e23      	ldr	r6, [pc, #140]	; (c7c <prvUnlockQueue+0xa0>)
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     bf0:	4d23      	ldr	r5, [pc, #140]	; (c80 <prvUnlockQueue+0xa4>)
     bf2:	e00b      	b.n	c0c <prvUnlockQueue+0x30>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     bf4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     bf6:	2b00      	cmp	r3, #0
     bf8:	d016      	beq.n	c28 <prvUnlockQueue+0x4c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     bfa:	0038      	movs	r0, r7
     bfc:	3024      	adds	r0, #36	; 0x24
     bfe:	47a8      	blx	r5
     c00:	2800      	cmp	r0, #0
     c02:	d10e      	bne.n	c22 <prvUnlockQueue+0x46>
     c04:	3c01      	subs	r4, #1
     c06:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     c08:	2c00      	cmp	r4, #0
     c0a:	d00d      	beq.n	c28 <prvUnlockQueue+0x4c>
				if( pxQueue->pxQueueSetContainer != NULL )
     c0c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     c0e:	2b00      	cmp	r3, #0
     c10:	d0f0      	beq.n	bf4 <prvUnlockQueue+0x18>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
     c12:	2100      	movs	r1, #0
     c14:	0038      	movs	r0, r7
     c16:	47b0      	blx	r6
     c18:	2800      	cmp	r0, #0
     c1a:	d0f3      	beq.n	c04 <prvUnlockQueue+0x28>
						vTaskMissedYield();
     c1c:	4b19      	ldr	r3, [pc, #100]	; (c84 <prvUnlockQueue+0xa8>)
     c1e:	4798      	blx	r3
     c20:	e7f0      	b.n	c04 <prvUnlockQueue+0x28>
							vTaskMissedYield();
     c22:	4b18      	ldr	r3, [pc, #96]	; (c84 <prvUnlockQueue+0xa8>)
     c24:	4798      	blx	r3
     c26:	e7ed      	b.n	c04 <prvUnlockQueue+0x28>
		pxQueue->cTxLock = queueUNLOCKED;
     c28:	22ff      	movs	r2, #255	; 0xff
     c2a:	2345      	movs	r3, #69	; 0x45
     c2c:	54fa      	strb	r2, [r7, r3]
	taskEXIT_CRITICAL();
     c2e:	4b16      	ldr	r3, [pc, #88]	; (c88 <prvUnlockQueue+0xac>)
     c30:	4798      	blx	r3
	taskENTER_CRITICAL();
     c32:	4b11      	ldr	r3, [pc, #68]	; (c78 <prvUnlockQueue+0x9c>)
     c34:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
     c36:	2344      	movs	r3, #68	; 0x44
     c38:	5cfc      	ldrb	r4, [r7, r3]
     c3a:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     c3c:	2c00      	cmp	r4, #0
     c3e:	dd14      	ble.n	c6a <prvUnlockQueue+0x8e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c40:	693b      	ldr	r3, [r7, #16]
     c42:	2b00      	cmp	r3, #0
     c44:	d011      	beq.n	c6a <prvUnlockQueue+0x8e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c46:	003d      	movs	r5, r7
     c48:	3510      	adds	r5, #16
     c4a:	4e0d      	ldr	r6, [pc, #52]	; (c80 <prvUnlockQueue+0xa4>)
     c4c:	e006      	b.n	c5c <prvUnlockQueue+0x80>
     c4e:	3c01      	subs	r4, #1
     c50:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     c52:	2c00      	cmp	r4, #0
     c54:	d009      	beq.n	c6a <prvUnlockQueue+0x8e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c56:	693b      	ldr	r3, [r7, #16]
     c58:	2b00      	cmp	r3, #0
     c5a:	d006      	beq.n	c6a <prvUnlockQueue+0x8e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c5c:	0028      	movs	r0, r5
     c5e:	47b0      	blx	r6
     c60:	2800      	cmp	r0, #0
     c62:	d0f4      	beq.n	c4e <prvUnlockQueue+0x72>
					vTaskMissedYield();
     c64:	4b07      	ldr	r3, [pc, #28]	; (c84 <prvUnlockQueue+0xa8>)
     c66:	4798      	blx	r3
     c68:	e7f1      	b.n	c4e <prvUnlockQueue+0x72>
		pxQueue->cRxLock = queueUNLOCKED;
     c6a:	22ff      	movs	r2, #255	; 0xff
     c6c:	2344      	movs	r3, #68	; 0x44
     c6e:	54fa      	strb	r2, [r7, r3]
	taskEXIT_CRITICAL();
     c70:	4b05      	ldr	r3, [pc, #20]	; (c88 <prvUnlockQueue+0xac>)
     c72:	4798      	blx	r3
}
     c74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     c76:	46c0      	nop			; (mov r8, r8)
     c78:	000009f1 	.word	0x000009f1
     c7c:	00000b4d 	.word	0x00000b4d
     c80:	00001b89 	.word	0x00001b89
     c84:	00001c85 	.word	0x00001c85
     c88:	00000a09 	.word	0x00000a09

00000c8c <xQueueGenericReset>:
{
     c8c:	b570      	push	{r4, r5, r6, lr}
     c8e:	0004      	movs	r4, r0
     c90:	000d      	movs	r5, r1
	configASSERT( pxQueue );
     c92:	2800      	cmp	r0, #0
     c94:	d021      	beq.n	cda <xQueueGenericReset+0x4e>
	taskENTER_CRITICAL();
     c96:	4b17      	ldr	r3, [pc, #92]	; (cf4 <xQueueGenericReset+0x68>)
     c98:	4798      	blx	r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     c9a:	6822      	ldr	r2, [r4, #0]
     c9c:	6c21      	ldr	r1, [r4, #64]	; 0x40
     c9e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     ca0:	434b      	muls	r3, r1
     ca2:	18d0      	adds	r0, r2, r3
     ca4:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     ca6:	2000      	movs	r0, #0
     ca8:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
     caa:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     cac:	1a5b      	subs	r3, r3, r1
     cae:	18d3      	adds	r3, r2, r3
     cb0:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
     cb2:	23ff      	movs	r3, #255	; 0xff
     cb4:	2244      	movs	r2, #68	; 0x44
     cb6:	54a3      	strb	r3, [r4, r2]
		pxQueue->cTxLock = queueUNLOCKED;
     cb8:	3201      	adds	r2, #1
     cba:	54a3      	strb	r3, [r4, r2]
		if( xNewQueue == pdFALSE )
     cbc:	2d00      	cmp	r5, #0
     cbe:	d111      	bne.n	ce4 <xQueueGenericReset+0x58>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     cc0:	6923      	ldr	r3, [r4, #16]
     cc2:	2b00      	cmp	r3, #0
     cc4:	d005      	beq.n	cd2 <xQueueGenericReset+0x46>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     cc6:	0020      	movs	r0, r4
     cc8:	3010      	adds	r0, #16
     cca:	4b0b      	ldr	r3, [pc, #44]	; (cf8 <xQueueGenericReset+0x6c>)
     ccc:	4798      	blx	r3
     cce:	2800      	cmp	r0, #0
     cd0:	d105      	bne.n	cde <xQueueGenericReset+0x52>
	taskEXIT_CRITICAL();
     cd2:	4b0a      	ldr	r3, [pc, #40]	; (cfc <xQueueGenericReset+0x70>)
     cd4:	4798      	blx	r3
}
     cd6:	2001      	movs	r0, #1
     cd8:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxQueue );
     cda:	b672      	cpsid	i
     cdc:	e7fe      	b.n	cdc <xQueueGenericReset+0x50>
					queueYIELD_IF_USING_PREEMPTION();
     cde:	4b08      	ldr	r3, [pc, #32]	; (d00 <xQueueGenericReset+0x74>)
     ce0:	4798      	blx	r3
     ce2:	e7f6      	b.n	cd2 <xQueueGenericReset+0x46>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     ce4:	0020      	movs	r0, r4
     ce6:	3010      	adds	r0, #16
     ce8:	4d06      	ldr	r5, [pc, #24]	; (d04 <xQueueGenericReset+0x78>)
     cea:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     cec:	0020      	movs	r0, r4
     cee:	3024      	adds	r0, #36	; 0x24
     cf0:	47a8      	blx	r5
     cf2:	e7ee      	b.n	cd2 <xQueueGenericReset+0x46>
     cf4:	000009f1 	.word	0x000009f1
     cf8:	00001b89 	.word	0x00001b89
     cfc:	00000a09 	.word	0x00000a09
     d00:	000009d9 	.word	0x000009d9
     d04:	00000321 	.word	0x00000321

00000d08 <xQueueGenericCreate>:
	{
     d08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     d0a:	0006      	movs	r6, r0
     d0c:	000d      	movs	r5, r1
     d0e:	0017      	movs	r7, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
     d10:	2800      	cmp	r0, #0
     d12:	d101      	bne.n	d18 <xQueueGenericCreate+0x10>
     d14:	b672      	cpsid	i
     d16:	e7fe      	b.n	d16 <xQueueGenericCreate+0xe>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d18:	0008      	movs	r0, r1
     d1a:	4370      	muls	r0, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     d1c:	3054      	adds	r0, #84	; 0x54
     d1e:	4b0b      	ldr	r3, [pc, #44]	; (d4c <xQueueGenericCreate+0x44>)
     d20:	4798      	blx	r3
     d22:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
     d24:	d010      	beq.n	d48 <xQueueGenericCreate+0x40>
	if( uxItemSize == ( UBaseType_t ) 0 )
     d26:	2d00      	cmp	r5, #0
     d28:	d003      	beq.n	d32 <xQueueGenericCreate+0x2a>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
     d2a:	0003      	movs	r3, r0
     d2c:	3354      	adds	r3, #84	; 0x54
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     d2e:	6003      	str	r3, [r0, #0]
     d30:	e000      	b.n	d34 <xQueueGenericCreate+0x2c>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     d32:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
     d34:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
     d36:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     d38:	2101      	movs	r1, #1
     d3a:	0020      	movs	r0, r4
     d3c:	4b04      	ldr	r3, [pc, #16]	; (d50 <xQueueGenericCreate+0x48>)
     d3e:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
     d40:	2350      	movs	r3, #80	; 0x50
     d42:	54e7      	strb	r7, [r4, r3]
		pxNewQueue->pxQueueSetContainer = NULL;
     d44:	2300      	movs	r3, #0
     d46:	64a3      	str	r3, [r4, #72]	; 0x48
	}
     d48:	0020      	movs	r0, r4
     d4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     d4c:	0000020d 	.word	0x0000020d
     d50:	00000c8d 	.word	0x00000c8d

00000d54 <xQueueGenericSend>:
{
     d54:	b5f0      	push	{r4, r5, r6, r7, lr}
     d56:	46ce      	mov	lr, r9
     d58:	4647      	mov	r7, r8
     d5a:	b580      	push	{r7, lr}
     d5c:	b085      	sub	sp, #20
     d5e:	0004      	movs	r4, r0
     d60:	000f      	movs	r7, r1
     d62:	9201      	str	r2, [sp, #4]
     d64:	001d      	movs	r5, r3
	configASSERT( pxQueue );
     d66:	2800      	cmp	r0, #0
     d68:	d00c      	beq.n	d84 <xQueueGenericSend+0x30>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     d6a:	2900      	cmp	r1, #0
     d6c:	d00c      	beq.n	d88 <xQueueGenericSend+0x34>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     d6e:	2d02      	cmp	r5, #2
     d70:	d00f      	beq.n	d92 <xQueueGenericSend+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     d72:	4b4e      	ldr	r3, [pc, #312]	; (eac <xQueueGenericSend+0x158>)
     d74:	4798      	blx	r3
     d76:	2800      	cmp	r0, #0
     d78:	d110      	bne.n	d9c <xQueueGenericSend+0x48>
     d7a:	9b01      	ldr	r3, [sp, #4]
     d7c:	2b00      	cmp	r3, #0
     d7e:	d011      	beq.n	da4 <xQueueGenericSend+0x50>
     d80:	b672      	cpsid	i
     d82:	e7fe      	b.n	d82 <xQueueGenericSend+0x2e>
	configASSERT( pxQueue );
     d84:	b672      	cpsid	i
     d86:	e7fe      	b.n	d86 <xQueueGenericSend+0x32>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     d88:	6c03      	ldr	r3, [r0, #64]	; 0x40
     d8a:	2b00      	cmp	r3, #0
     d8c:	d0ef      	beq.n	d6e <xQueueGenericSend+0x1a>
     d8e:	b672      	cpsid	i
     d90:	e7fe      	b.n	d90 <xQueueGenericSend+0x3c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     d92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     d94:	2b01      	cmp	r3, #1
     d96:	d0ec      	beq.n	d72 <xQueueGenericSend+0x1e>
     d98:	b672      	cpsid	i
     d9a:	e7fe      	b.n	d9a <xQueueGenericSend+0x46>
     d9c:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
     d9e:	4b44      	ldr	r3, [pc, #272]	; (eb0 <xQueueGenericSend+0x15c>)
     da0:	4698      	mov	r8, r3
     da2:	e04c      	b.n	e3e <xQueueGenericSend+0xea>
     da4:	2600      	movs	r6, #0
     da6:	e7fa      	b.n	d9e <xQueueGenericSend+0x4a>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     da8:	002a      	movs	r2, r5
     daa:	0039      	movs	r1, r7
     dac:	0020      	movs	r0, r4
     dae:	4b41      	ldr	r3, [pc, #260]	; (eb4 <xQueueGenericSend+0x160>)
     db0:	4798      	blx	r3
					if( pxQueue->pxQueueSetContainer != NULL )
     db2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     db4:	2b00      	cmp	r3, #0
     db6:	d00f      	beq.n	dd8 <xQueueGenericSend+0x84>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     db8:	0029      	movs	r1, r5
     dba:	0020      	movs	r0, r4
     dbc:	4b3e      	ldr	r3, [pc, #248]	; (eb8 <xQueueGenericSend+0x164>)
     dbe:	4798      	blx	r3
     dc0:	2800      	cmp	r0, #0
     dc2:	d001      	beq.n	dc8 <xQueueGenericSend+0x74>
							queueYIELD_IF_USING_PREEMPTION();
     dc4:	4b3d      	ldr	r3, [pc, #244]	; (ebc <xQueueGenericSend+0x168>)
     dc6:	4798      	blx	r3
				taskEXIT_CRITICAL();
     dc8:	4b3d      	ldr	r3, [pc, #244]	; (ec0 <xQueueGenericSend+0x16c>)
     dca:	4798      	blx	r3
				return pdPASS;
     dcc:	2001      	movs	r0, #1
}
     dce:	b005      	add	sp, #20
     dd0:	bc0c      	pop	{r2, r3}
     dd2:	4690      	mov	r8, r2
     dd4:	4699      	mov	r9, r3
     dd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     dd8:	6a63      	ldr	r3, [r4, #36]	; 0x24
     dda:	2b00      	cmp	r3, #0
     ddc:	d008      	beq.n	df0 <xQueueGenericSend+0x9c>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     dde:	0020      	movs	r0, r4
     de0:	3024      	adds	r0, #36	; 0x24
     de2:	4b38      	ldr	r3, [pc, #224]	; (ec4 <xQueueGenericSend+0x170>)
     de4:	4798      	blx	r3
     de6:	2800      	cmp	r0, #0
     de8:	d0ee      	beq.n	dc8 <xQueueGenericSend+0x74>
								queueYIELD_IF_USING_PREEMPTION();
     dea:	4b34      	ldr	r3, [pc, #208]	; (ebc <xQueueGenericSend+0x168>)
     dec:	4798      	blx	r3
     dee:	e7eb      	b.n	dc8 <xQueueGenericSend+0x74>
						else if( xYieldRequired != pdFALSE )
     df0:	2800      	cmp	r0, #0
     df2:	d0e9      	beq.n	dc8 <xQueueGenericSend+0x74>
							queueYIELD_IF_USING_PREEMPTION();
     df4:	4b31      	ldr	r3, [pc, #196]	; (ebc <xQueueGenericSend+0x168>)
     df6:	4798      	blx	r3
     df8:	e7e6      	b.n	dc8 <xQueueGenericSend+0x74>
					taskEXIT_CRITICAL();
     dfa:	4b31      	ldr	r3, [pc, #196]	; (ec0 <xQueueGenericSend+0x16c>)
     dfc:	4798      	blx	r3
					return errQUEUE_FULL;
     dfe:	2000      	movs	r0, #0
     e00:	e7e5      	b.n	dce <xQueueGenericSend+0x7a>
		prvLockQueue( pxQueue );
     e02:	4b2f      	ldr	r3, [pc, #188]	; (ec0 <xQueueGenericSend+0x16c>)
     e04:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e06:	a901      	add	r1, sp, #4
     e08:	a802      	add	r0, sp, #8
     e0a:	4b2f      	ldr	r3, [pc, #188]	; (ec8 <xQueueGenericSend+0x174>)
     e0c:	4798      	blx	r3
     e0e:	2800      	cmp	r0, #0
     e10:	d144      	bne.n	e9c <xQueueGenericSend+0x148>
	taskENTER_CRITICAL();
     e12:	4b27      	ldr	r3, [pc, #156]	; (eb0 <xQueueGenericSend+0x15c>)
     e14:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     e16:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     e18:	4699      	mov	r9, r3
     e1a:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
     e1c:	4b28      	ldr	r3, [pc, #160]	; (ec0 <xQueueGenericSend+0x16c>)
     e1e:	4798      	blx	r3
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     e20:	45b1      	cmp	r9, r6
     e22:	d135      	bne.n	e90 <xQueueGenericSend+0x13c>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e24:	0020      	movs	r0, r4
     e26:	3010      	adds	r0, #16
     e28:	9901      	ldr	r1, [sp, #4]
     e2a:	4b28      	ldr	r3, [pc, #160]	; (ecc <xQueueGenericSend+0x178>)
     e2c:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
     e2e:	0020      	movs	r0, r4
     e30:	4b27      	ldr	r3, [pc, #156]	; (ed0 <xQueueGenericSend+0x17c>)
     e32:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
     e34:	4b27      	ldr	r3, [pc, #156]	; (ed4 <xQueueGenericSend+0x180>)
     e36:	4798      	blx	r3
     e38:	2800      	cmp	r0, #0
     e3a:	d026      	beq.n	e8a <xQueueGenericSend+0x136>
     e3c:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
     e3e:	47c0      	blx	r8
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     e40:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     e42:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     e44:	4293      	cmp	r3, r2
     e46:	d3af      	bcc.n	da8 <xQueueGenericSend+0x54>
     e48:	2d02      	cmp	r5, #2
     e4a:	d0ad      	beq.n	da8 <xQueueGenericSend+0x54>
				if( xTicksToWait == ( TickType_t ) 0 )
     e4c:	9b01      	ldr	r3, [sp, #4]
     e4e:	2b00      	cmp	r3, #0
     e50:	d0d3      	beq.n	dfa <xQueueGenericSend+0xa6>
				else if( xEntryTimeSet == pdFALSE )
     e52:	2e00      	cmp	r6, #0
     e54:	d102      	bne.n	e5c <xQueueGenericSend+0x108>
					vTaskInternalSetTimeOutState( &xTimeOut );
     e56:	a802      	add	r0, sp, #8
     e58:	4b1f      	ldr	r3, [pc, #124]	; (ed8 <xQueueGenericSend+0x184>)
     e5a:	4798      	blx	r3
		taskEXIT_CRITICAL();
     e5c:	4b18      	ldr	r3, [pc, #96]	; (ec0 <xQueueGenericSend+0x16c>)
     e5e:	4798      	blx	r3
		vTaskSuspendAll();
     e60:	4b1e      	ldr	r3, [pc, #120]	; (edc <xQueueGenericSend+0x188>)
     e62:	4798      	blx	r3
		prvLockQueue( pxQueue );
     e64:	4b12      	ldr	r3, [pc, #72]	; (eb0 <xQueueGenericSend+0x15c>)
     e66:	4798      	blx	r3
     e68:	2344      	movs	r3, #68	; 0x44
     e6a:	5ce3      	ldrb	r3, [r4, r3]
     e6c:	b25b      	sxtb	r3, r3
     e6e:	3301      	adds	r3, #1
     e70:	d102      	bne.n	e78 <xQueueGenericSend+0x124>
     e72:	2200      	movs	r2, #0
     e74:	2344      	movs	r3, #68	; 0x44
     e76:	54e2      	strb	r2, [r4, r3]
     e78:	2345      	movs	r3, #69	; 0x45
     e7a:	5ce3      	ldrb	r3, [r4, r3]
     e7c:	b25b      	sxtb	r3, r3
     e7e:	3301      	adds	r3, #1
     e80:	d1bf      	bne.n	e02 <xQueueGenericSend+0xae>
     e82:	2200      	movs	r2, #0
     e84:	2345      	movs	r3, #69	; 0x45
     e86:	54e2      	strb	r2, [r4, r3]
     e88:	e7bb      	b.n	e02 <xQueueGenericSend+0xae>
					portYIELD_WITHIN_API();
     e8a:	4b0c      	ldr	r3, [pc, #48]	; (ebc <xQueueGenericSend+0x168>)
     e8c:	4798      	blx	r3
     e8e:	e7d5      	b.n	e3c <xQueueGenericSend+0xe8>
				prvUnlockQueue( pxQueue );
     e90:	0020      	movs	r0, r4
     e92:	4b0f      	ldr	r3, [pc, #60]	; (ed0 <xQueueGenericSend+0x17c>)
     e94:	4798      	blx	r3
				( void ) xTaskResumeAll();
     e96:	4b0f      	ldr	r3, [pc, #60]	; (ed4 <xQueueGenericSend+0x180>)
     e98:	4798      	blx	r3
     e9a:	e7cf      	b.n	e3c <xQueueGenericSend+0xe8>
			prvUnlockQueue( pxQueue );
     e9c:	0020      	movs	r0, r4
     e9e:	4b0c      	ldr	r3, [pc, #48]	; (ed0 <xQueueGenericSend+0x17c>)
     ea0:	4798      	blx	r3
			( void ) xTaskResumeAll();
     ea2:	4b0c      	ldr	r3, [pc, #48]	; (ed4 <xQueueGenericSend+0x180>)
     ea4:	4798      	blx	r3
			return errQUEUE_FULL;
     ea6:	2000      	movs	r0, #0
     ea8:	e791      	b.n	dce <xQueueGenericSend+0x7a>
     eaa:	46c0      	nop			; (mov r8, r8)
     eac:	00001c91 	.word	0x00001c91
     eb0:	000009f1 	.word	0x000009f1
     eb4:	00000ad1 	.word	0x00000ad1
     eb8:	00000b4d 	.word	0x00000b4d
     ebc:	000009d9 	.word	0x000009d9
     ec0:	00000a09 	.word	0x00000a09
     ec4:	00001b89 	.word	0x00001b89
     ec8:	00001c19 	.word	0x00001c19
     ecc:	00001b25 	.word	0x00001b25
     ed0:	00000bdd 	.word	0x00000bdd
     ed4:	0000195d 	.word	0x0000195d
     ed8:	00001c09 	.word	0x00001c09
     edc:	00001831 	.word	0x00001831

00000ee0 <xQueueGenericSendFromISR>:
{
     ee0:	b5f0      	push	{r4, r5, r6, r7, lr}
     ee2:	b083      	sub	sp, #12
     ee4:	0004      	movs	r4, r0
     ee6:	9101      	str	r1, [sp, #4]
     ee8:	0016      	movs	r6, r2
     eea:	001d      	movs	r5, r3
	configASSERT( pxQueue );
     eec:	2800      	cmp	r0, #0
     eee:	d012      	beq.n	f16 <xQueueGenericSendFromISR+0x36>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     ef0:	9b01      	ldr	r3, [sp, #4]
     ef2:	2b00      	cmp	r3, #0
     ef4:	d011      	beq.n	f1a <xQueueGenericSendFromISR+0x3a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     ef6:	2d02      	cmp	r5, #2
     ef8:	d014      	beq.n	f24 <xQueueGenericSendFromISR+0x44>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     efa:	4b28      	ldr	r3, [pc, #160]	; (f9c <xQueueGenericSendFromISR+0xbc>)
     efc:	4798      	blx	r3
     efe:	9000      	str	r0, [sp, #0]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     f00:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     f02:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     f04:	429a      	cmp	r2, r3
     f06:	d82f      	bhi.n	f68 <xQueueGenericSendFromISR+0x88>
			xReturn = errQUEUE_FULL;
     f08:	2500      	movs	r5, #0
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
     f0a:	9800      	ldr	r0, [sp, #0]
     f0c:	4b24      	ldr	r3, [pc, #144]	; (fa0 <xQueueGenericSendFromISR+0xc0>)
     f0e:	4798      	blx	r3
}
     f10:	0028      	movs	r0, r5
     f12:	b003      	add	sp, #12
     f14:	bdf0      	pop	{r4, r5, r6, r7, pc}
	configASSERT( pxQueue );
     f16:	b672      	cpsid	i
     f18:	e7fe      	b.n	f18 <xQueueGenericSendFromISR+0x38>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     f1a:	6c03      	ldr	r3, [r0, #64]	; 0x40
     f1c:	2b00      	cmp	r3, #0
     f1e:	d0ea      	beq.n	ef6 <xQueueGenericSendFromISR+0x16>
     f20:	b672      	cpsid	i
     f22:	e7fe      	b.n	f22 <xQueueGenericSendFromISR+0x42>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     f24:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     f26:	2b01      	cmp	r3, #1
     f28:	d01a      	beq.n	f60 <xQueueGenericSendFromISR+0x80>
     f2a:	b672      	cpsid	i
     f2c:	e7fe      	b.n	f2c <xQueueGenericSendFromISR+0x4c>
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f2e:	6a63      	ldr	r3, [r4, #36]	; 0x24
			xReturn = pdPASS;
     f30:	2501      	movs	r5, #1
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f32:	2b00      	cmp	r3, #0
     f34:	d0e9      	beq.n	f0a <xQueueGenericSendFromISR+0x2a>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f36:	0020      	movs	r0, r4
     f38:	3024      	adds	r0, #36	; 0x24
     f3a:	4b1a      	ldr	r3, [pc, #104]	; (fa4 <xQueueGenericSendFromISR+0xc4>)
     f3c:	4798      	blx	r3
     f3e:	2800      	cmp	r0, #0
     f40:	d0e3      	beq.n	f0a <xQueueGenericSendFromISR+0x2a>
								if( pxHigherPriorityTaskWoken != NULL )
     f42:	2e00      	cmp	r6, #0
     f44:	d00a      	beq.n	f5c <xQueueGenericSendFromISR+0x7c>
									*pxHigherPriorityTaskWoken = pdTRUE;
     f46:	2301      	movs	r3, #1
     f48:	6033      	str	r3, [r6, #0]
     f4a:	e7de      	b.n	f0a <xQueueGenericSendFromISR+0x2a>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     f4c:	1c7b      	adds	r3, r7, #1
     f4e:	b25b      	sxtb	r3, r3
     f50:	2245      	movs	r2, #69	; 0x45
     f52:	54a3      	strb	r3, [r4, r2]
			xReturn = pdPASS;
     f54:	2501      	movs	r5, #1
     f56:	e7d8      	b.n	f0a <xQueueGenericSendFromISR+0x2a>
     f58:	2501      	movs	r5, #1
     f5a:	e7d6      	b.n	f0a <xQueueGenericSendFromISR+0x2a>
     f5c:	2501      	movs	r5, #1
     f5e:	e7d4      	b.n	f0a <xQueueGenericSendFromISR+0x2a>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     f60:	4b0e      	ldr	r3, [pc, #56]	; (f9c <xQueueGenericSendFromISR+0xbc>)
     f62:	4798      	blx	r3
     f64:	9000      	str	r0, [sp, #0]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     f66:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
     f68:	2345      	movs	r3, #69	; 0x45
     f6a:	5ce7      	ldrb	r7, [r4, r3]
     f6c:	b27f      	sxtb	r7, r7
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     f6e:	002a      	movs	r2, r5
     f70:	9901      	ldr	r1, [sp, #4]
     f72:	0020      	movs	r0, r4
     f74:	4b0c      	ldr	r3, [pc, #48]	; (fa8 <xQueueGenericSendFromISR+0xc8>)
     f76:	4798      	blx	r3
			if( cTxLock == queueUNLOCKED )
     f78:	1c7b      	adds	r3, r7, #1
     f7a:	d1e7      	bne.n	f4c <xQueueGenericSendFromISR+0x6c>
					if( pxQueue->pxQueueSetContainer != NULL )
     f7c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     f7e:	2b00      	cmp	r3, #0
     f80:	d0d5      	beq.n	f2e <xQueueGenericSendFromISR+0x4e>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     f82:	0029      	movs	r1, r5
     f84:	0020      	movs	r0, r4
     f86:	4b09      	ldr	r3, [pc, #36]	; (fac <xQueueGenericSendFromISR+0xcc>)
     f88:	4798      	blx	r3
			xReturn = pdPASS;
     f8a:	2501      	movs	r5, #1
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     f8c:	2800      	cmp	r0, #0
     f8e:	d0bc      	beq.n	f0a <xQueueGenericSendFromISR+0x2a>
							if( pxHigherPriorityTaskWoken != NULL )
     f90:	2e00      	cmp	r6, #0
     f92:	d0e1      	beq.n	f58 <xQueueGenericSendFromISR+0x78>
								*pxHigherPriorityTaskWoken = pdTRUE;
     f94:	2301      	movs	r3, #1
     f96:	6033      	str	r3, [r6, #0]
     f98:	e7b7      	b.n	f0a <xQueueGenericSendFromISR+0x2a>
     f9a:	46c0      	nop			; (mov r8, r8)
     f9c:	00000a29 	.word	0x00000a29
     fa0:	00000a31 	.word	0x00000a31
     fa4:	00001b89 	.word	0x00001b89
     fa8:	00000ad1 	.word	0x00000ad1
     fac:	00000b4d 	.word	0x00000b4d

00000fb0 <xQueueReceive>:
{
     fb0:	b5f0      	push	{r4, r5, r6, r7, lr}
     fb2:	46c6      	mov	lr, r8
     fb4:	b500      	push	{lr}
     fb6:	b084      	sub	sp, #16
     fb8:	0004      	movs	r4, r0
     fba:	000f      	movs	r7, r1
     fbc:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
     fbe:	2800      	cmp	r0, #0
     fc0:	d00a      	beq.n	fd8 <xQueueReceive+0x28>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
     fc2:	2900      	cmp	r1, #0
     fc4:	d00a      	beq.n	fdc <xQueueReceive+0x2c>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     fc6:	4b42      	ldr	r3, [pc, #264]	; (10d0 <xQueueReceive+0x120>)
     fc8:	4798      	blx	r3
     fca:	2800      	cmp	r0, #0
     fcc:	d10b      	bne.n	fe6 <xQueueReceive+0x36>
     fce:	9b01      	ldr	r3, [sp, #4]
     fd0:	2b00      	cmp	r3, #0
     fd2:	d00c      	beq.n	fee <xQueueReceive+0x3e>
     fd4:	b672      	cpsid	i
     fd6:	e7fe      	b.n	fd6 <xQueueReceive+0x26>
	configASSERT( ( pxQueue ) );
     fd8:	b672      	cpsid	i
     fda:	e7fe      	b.n	fda <xQueueReceive+0x2a>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
     fdc:	6c03      	ldr	r3, [r0, #64]	; 0x40
     fde:	2b00      	cmp	r3, #0
     fe0:	d0f1      	beq.n	fc6 <xQueueReceive+0x16>
     fe2:	b672      	cpsid	i
     fe4:	e7fe      	b.n	fe4 <xQueueReceive+0x34>
     fe6:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
     fe8:	4b3a      	ldr	r3, [pc, #232]	; (10d4 <xQueueReceive+0x124>)
     fea:	4698      	mov	r8, r3
     fec:	e02f      	b.n	104e <xQueueReceive+0x9e>
     fee:	2600      	movs	r6, #0
     ff0:	e7fa      	b.n	fe8 <xQueueReceive+0x38>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
     ff2:	0039      	movs	r1, r7
     ff4:	0020      	movs	r0, r4
     ff6:	4b38      	ldr	r3, [pc, #224]	; (10d8 <xQueueReceive+0x128>)
     ff8:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
     ffa:	3d01      	subs	r5, #1
     ffc:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ffe:	6923      	ldr	r3, [r4, #16]
    1000:	2b00      	cmp	r3, #0
    1002:	d007      	beq.n	1014 <xQueueReceive+0x64>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1004:	0020      	movs	r0, r4
    1006:	3010      	adds	r0, #16
    1008:	4b34      	ldr	r3, [pc, #208]	; (10dc <xQueueReceive+0x12c>)
    100a:	4798      	blx	r3
    100c:	2800      	cmp	r0, #0
    100e:	d001      	beq.n	1014 <xQueueReceive+0x64>
						queueYIELD_IF_USING_PREEMPTION();
    1010:	4b33      	ldr	r3, [pc, #204]	; (10e0 <xQueueReceive+0x130>)
    1012:	4798      	blx	r3
				taskEXIT_CRITICAL();
    1014:	4b33      	ldr	r3, [pc, #204]	; (10e4 <xQueueReceive+0x134>)
    1016:	4798      	blx	r3
				return pdPASS;
    1018:	2001      	movs	r0, #1
}
    101a:	b004      	add	sp, #16
    101c:	bc04      	pop	{r2}
    101e:	4690      	mov	r8, r2
    1020:	bdf0      	pop	{r4, r5, r6, r7, pc}
					taskEXIT_CRITICAL();
    1022:	4b30      	ldr	r3, [pc, #192]	; (10e4 <xQueueReceive+0x134>)
    1024:	4798      	blx	r3
					return errQUEUE_EMPTY;
    1026:	2000      	movs	r0, #0
    1028:	e7f7      	b.n	101a <xQueueReceive+0x6a>
					vTaskInternalSetTimeOutState( &xTimeOut );
    102a:	a802      	add	r0, sp, #8
    102c:	4b2e      	ldr	r3, [pc, #184]	; (10e8 <xQueueReceive+0x138>)
    102e:	4798      	blx	r3
    1030:	e016      	b.n	1060 <xQueueReceive+0xb0>
		prvLockQueue( pxQueue );
    1032:	2200      	movs	r2, #0
    1034:	2344      	movs	r3, #68	; 0x44
    1036:	54e2      	strb	r2, [r4, r3]
    1038:	e01d      	b.n	1076 <xQueueReceive+0xc6>
    103a:	2200      	movs	r2, #0
    103c:	2345      	movs	r3, #69	; 0x45
    103e:	54e2      	strb	r2, [r4, r3]
    1040:	e01e      	b.n	1080 <xQueueReceive+0xd0>
				prvUnlockQueue( pxQueue );
    1042:	0020      	movs	r0, r4
    1044:	4b29      	ldr	r3, [pc, #164]	; (10ec <xQueueReceive+0x13c>)
    1046:	4798      	blx	r3
				( void ) xTaskResumeAll();
    1048:	4b29      	ldr	r3, [pc, #164]	; (10f0 <xQueueReceive+0x140>)
    104a:	4798      	blx	r3
    104c:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    104e:	47c0      	blx	r8
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1050:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1052:	2d00      	cmp	r5, #0
    1054:	d1cd      	bne.n	ff2 <xQueueReceive+0x42>
				if( xTicksToWait == ( TickType_t ) 0 )
    1056:	9b01      	ldr	r3, [sp, #4]
    1058:	2b00      	cmp	r3, #0
    105a:	d0e2      	beq.n	1022 <xQueueReceive+0x72>
				else if( xEntryTimeSet == pdFALSE )
    105c:	2e00      	cmp	r6, #0
    105e:	d0e4      	beq.n	102a <xQueueReceive+0x7a>
		taskEXIT_CRITICAL();
    1060:	4b20      	ldr	r3, [pc, #128]	; (10e4 <xQueueReceive+0x134>)
    1062:	4798      	blx	r3
		vTaskSuspendAll();
    1064:	4b23      	ldr	r3, [pc, #140]	; (10f4 <xQueueReceive+0x144>)
    1066:	4798      	blx	r3
		prvLockQueue( pxQueue );
    1068:	4b1a      	ldr	r3, [pc, #104]	; (10d4 <xQueueReceive+0x124>)
    106a:	4798      	blx	r3
    106c:	2344      	movs	r3, #68	; 0x44
    106e:	5ce3      	ldrb	r3, [r4, r3]
    1070:	b25b      	sxtb	r3, r3
    1072:	3301      	adds	r3, #1
    1074:	d0dd      	beq.n	1032 <xQueueReceive+0x82>
    1076:	2345      	movs	r3, #69	; 0x45
    1078:	5ce3      	ldrb	r3, [r4, r3]
    107a:	b25b      	sxtb	r3, r3
    107c:	3301      	adds	r3, #1
    107e:	d0dc      	beq.n	103a <xQueueReceive+0x8a>
    1080:	4b18      	ldr	r3, [pc, #96]	; (10e4 <xQueueReceive+0x134>)
    1082:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1084:	a901      	add	r1, sp, #4
    1086:	a802      	add	r0, sp, #8
    1088:	4b1b      	ldr	r3, [pc, #108]	; (10f8 <xQueueReceive+0x148>)
    108a:	4798      	blx	r3
    108c:	2800      	cmp	r0, #0
    108e:	d113      	bne.n	10b8 <xQueueReceive+0x108>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1090:	0020      	movs	r0, r4
    1092:	4b1a      	ldr	r3, [pc, #104]	; (10fc <xQueueReceive+0x14c>)
    1094:	4798      	blx	r3
    1096:	2800      	cmp	r0, #0
    1098:	d0d3      	beq.n	1042 <xQueueReceive+0x92>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    109a:	0020      	movs	r0, r4
    109c:	3024      	adds	r0, #36	; 0x24
    109e:	9901      	ldr	r1, [sp, #4]
    10a0:	4b17      	ldr	r3, [pc, #92]	; (1100 <xQueueReceive+0x150>)
    10a2:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
    10a4:	0020      	movs	r0, r4
    10a6:	4b11      	ldr	r3, [pc, #68]	; (10ec <xQueueReceive+0x13c>)
    10a8:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    10aa:	4b11      	ldr	r3, [pc, #68]	; (10f0 <xQueueReceive+0x140>)
    10ac:	4798      	blx	r3
    10ae:	2800      	cmp	r0, #0
    10b0:	d1cc      	bne.n	104c <xQueueReceive+0x9c>
					portYIELD_WITHIN_API();
    10b2:	4b0b      	ldr	r3, [pc, #44]	; (10e0 <xQueueReceive+0x130>)
    10b4:	4798      	blx	r3
    10b6:	e7c9      	b.n	104c <xQueueReceive+0x9c>
			prvUnlockQueue( pxQueue );
    10b8:	0020      	movs	r0, r4
    10ba:	4b0c      	ldr	r3, [pc, #48]	; (10ec <xQueueReceive+0x13c>)
    10bc:	4798      	blx	r3
			( void ) xTaskResumeAll();
    10be:	4b0c      	ldr	r3, [pc, #48]	; (10f0 <xQueueReceive+0x140>)
    10c0:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    10c2:	0020      	movs	r0, r4
    10c4:	4b0d      	ldr	r3, [pc, #52]	; (10fc <xQueueReceive+0x14c>)
    10c6:	4798      	blx	r3
    10c8:	2800      	cmp	r0, #0
    10ca:	d0bf      	beq.n	104c <xQueueReceive+0x9c>
				return errQUEUE_EMPTY;
    10cc:	2000      	movs	r0, #0
    10ce:	e7a4      	b.n	101a <xQueueReceive+0x6a>
    10d0:	00001c91 	.word	0x00001c91
    10d4:	000009f1 	.word	0x000009f1
    10d8:	00000bb5 	.word	0x00000bb5
    10dc:	00001b89 	.word	0x00001b89
    10e0:	000009d9 	.word	0x000009d9
    10e4:	00000a09 	.word	0x00000a09
    10e8:	00001c09 	.word	0x00001c09
    10ec:	00000bdd 	.word	0x00000bdd
    10f0:	0000195d 	.word	0x0000195d
    10f4:	00001831 	.word	0x00001831
    10f8:	00001c19 	.word	0x00001c19
    10fc:	00000ab5 	.word	0x00000ab5
    1100:	00001b25 	.word	0x00001b25

00001104 <xQueueSemaphoreTake>:
{
    1104:	b5f0      	push	{r4, r5, r6, r7, lr}
    1106:	b085      	sub	sp, #20
    1108:	1e04      	subs	r4, r0, #0
    110a:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
    110c:	d004      	beq.n	1118 <xQueueSemaphoreTake+0x14>
	configASSERT( pxQueue->uxItemSize == 0 );
    110e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1110:	2b00      	cmp	r3, #0
    1112:	d003      	beq.n	111c <xQueueSemaphoreTake+0x18>
    1114:	b672      	cpsid	i
    1116:	e7fe      	b.n	1116 <xQueueSemaphoreTake+0x12>
	configASSERT( ( pxQueue ) );
    1118:	b672      	cpsid	i
    111a:	e7fe      	b.n	111a <xQueueSemaphoreTake+0x16>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    111c:	4b50      	ldr	r3, [pc, #320]	; (1260 <xQueueSemaphoreTake+0x15c>)
    111e:	4798      	blx	r3
    1120:	2800      	cmp	r0, #0
    1122:	d104      	bne.n	112e <xQueueSemaphoreTake+0x2a>
    1124:	9b01      	ldr	r3, [sp, #4]
    1126:	2b00      	cmp	r3, #0
    1128:	d005      	beq.n	1136 <xQueueSemaphoreTake+0x32>
    112a:	b672      	cpsid	i
    112c:	e7fe      	b.n	112c <xQueueSemaphoreTake+0x28>
    112e:	2500      	movs	r5, #0
    1130:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    1132:	4f4c      	ldr	r7, [pc, #304]	; (1264 <xQueueSemaphoreTake+0x160>)
    1134:	e048      	b.n	11c8 <xQueueSemaphoreTake+0xc4>
    1136:	2500      	movs	r5, #0
    1138:	2600      	movs	r6, #0
    113a:	e7fa      	b.n	1132 <xQueueSemaphoreTake+0x2e>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    113c:	3b01      	subs	r3, #1
    113e:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1140:	6823      	ldr	r3, [r4, #0]
    1142:	2b00      	cmp	r3, #0
    1144:	d102      	bne.n	114c <xQueueSemaphoreTake+0x48>
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1146:	4b48      	ldr	r3, [pc, #288]	; (1268 <xQueueSemaphoreTake+0x164>)
    1148:	4798      	blx	r3
    114a:	6060      	str	r0, [r4, #4]
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    114c:	6923      	ldr	r3, [r4, #16]
    114e:	2b00      	cmp	r3, #0
    1150:	d007      	beq.n	1162 <xQueueSemaphoreTake+0x5e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1152:	0020      	movs	r0, r4
    1154:	3010      	adds	r0, #16
    1156:	4b45      	ldr	r3, [pc, #276]	; (126c <xQueueSemaphoreTake+0x168>)
    1158:	4798      	blx	r3
    115a:	2800      	cmp	r0, #0
    115c:	d001      	beq.n	1162 <xQueueSemaphoreTake+0x5e>
						queueYIELD_IF_USING_PREEMPTION();
    115e:	4b44      	ldr	r3, [pc, #272]	; (1270 <xQueueSemaphoreTake+0x16c>)
    1160:	4798      	blx	r3
				taskEXIT_CRITICAL();
    1162:	4b44      	ldr	r3, [pc, #272]	; (1274 <xQueueSemaphoreTake+0x170>)
    1164:	4798      	blx	r3
				return pdPASS;
    1166:	2501      	movs	r5, #1
}
    1168:	0028      	movs	r0, r5
    116a:	b005      	add	sp, #20
    116c:	bdf0      	pop	{r4, r5, r6, r7, pc}
						configASSERT( xInheritanceOccurred == pdFALSE );
    116e:	2d00      	cmp	r5, #0
    1170:	d001      	beq.n	1176 <xQueueSemaphoreTake+0x72>
    1172:	b672      	cpsid	i
    1174:	e7fe      	b.n	1174 <xQueueSemaphoreTake+0x70>
					taskEXIT_CRITICAL();
    1176:	4b3f      	ldr	r3, [pc, #252]	; (1274 <xQueueSemaphoreTake+0x170>)
    1178:	4798      	blx	r3
					return errQUEUE_EMPTY;
    117a:	e7f5      	b.n	1168 <xQueueSemaphoreTake+0x64>
					vTaskInternalSetTimeOutState( &xTimeOut );
    117c:	a802      	add	r0, sp, #8
    117e:	4b3e      	ldr	r3, [pc, #248]	; (1278 <xQueueSemaphoreTake+0x174>)
    1180:	4798      	blx	r3
    1182:	e02a      	b.n	11da <xQueueSemaphoreTake+0xd6>
		prvLockQueue( pxQueue );
    1184:	2200      	movs	r2, #0
    1186:	2344      	movs	r3, #68	; 0x44
    1188:	54e2      	strb	r2, [r4, r3]
    118a:	e031      	b.n	11f0 <xQueueSemaphoreTake+0xec>
    118c:	2200      	movs	r2, #0
    118e:	2345      	movs	r3, #69	; 0x45
    1190:	54e2      	strb	r2, [r4, r3]
    1192:	e032      	b.n	11fa <xQueueSemaphoreTake+0xf6>
						taskENTER_CRITICAL();
    1194:	4b33      	ldr	r3, [pc, #204]	; (1264 <xQueueSemaphoreTake+0x160>)
    1196:	4798      	blx	r3
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1198:	6860      	ldr	r0, [r4, #4]
    119a:	4b38      	ldr	r3, [pc, #224]	; (127c <xQueueSemaphoreTake+0x178>)
    119c:	4798      	blx	r3
    119e:	0005      	movs	r5, r0
						taskEXIT_CRITICAL();
    11a0:	4b34      	ldr	r3, [pc, #208]	; (1274 <xQueueSemaphoreTake+0x170>)
    11a2:	4798      	blx	r3
    11a4:	e039      	b.n	121a <xQueueSemaphoreTake+0x116>
				prvUnlockQueue( pxQueue );
    11a6:	0020      	movs	r0, r4
    11a8:	4b35      	ldr	r3, [pc, #212]	; (1280 <xQueueSemaphoreTake+0x17c>)
    11aa:	4798      	blx	r3
				( void ) xTaskResumeAll();
    11ac:	4b35      	ldr	r3, [pc, #212]	; (1284 <xQueueSemaphoreTake+0x180>)
    11ae:	4798      	blx	r3
    11b0:	e009      	b.n	11c6 <xQueueSemaphoreTake+0xc2>
			prvUnlockQueue( pxQueue );
    11b2:	0020      	movs	r0, r4
    11b4:	4b32      	ldr	r3, [pc, #200]	; (1280 <xQueueSemaphoreTake+0x17c>)
    11b6:	4798      	blx	r3
			( void ) xTaskResumeAll();
    11b8:	4b32      	ldr	r3, [pc, #200]	; (1284 <xQueueSemaphoreTake+0x180>)
    11ba:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    11bc:	0020      	movs	r0, r4
    11be:	4b32      	ldr	r3, [pc, #200]	; (1288 <xQueueSemaphoreTake+0x184>)
    11c0:	4798      	blx	r3
    11c2:	2800      	cmp	r0, #0
    11c4:	d138      	bne.n	1238 <xQueueSemaphoreTake+0x134>
    11c6:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    11c8:	47b8      	blx	r7
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    11ca:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    11cc:	2b00      	cmp	r3, #0
    11ce:	d1b5      	bne.n	113c <xQueueSemaphoreTake+0x38>
				if( xTicksToWait == ( TickType_t ) 0 )
    11d0:	9b01      	ldr	r3, [sp, #4]
    11d2:	2b00      	cmp	r3, #0
    11d4:	d0cb      	beq.n	116e <xQueueSemaphoreTake+0x6a>
				else if( xEntryTimeSet == pdFALSE )
    11d6:	2e00      	cmp	r6, #0
    11d8:	d0d0      	beq.n	117c <xQueueSemaphoreTake+0x78>
		taskEXIT_CRITICAL();
    11da:	4b26      	ldr	r3, [pc, #152]	; (1274 <xQueueSemaphoreTake+0x170>)
    11dc:	4798      	blx	r3
		vTaskSuspendAll();
    11de:	4b2b      	ldr	r3, [pc, #172]	; (128c <xQueueSemaphoreTake+0x188>)
    11e0:	4798      	blx	r3
		prvLockQueue( pxQueue );
    11e2:	4b20      	ldr	r3, [pc, #128]	; (1264 <xQueueSemaphoreTake+0x160>)
    11e4:	4798      	blx	r3
    11e6:	2344      	movs	r3, #68	; 0x44
    11e8:	5ce3      	ldrb	r3, [r4, r3]
    11ea:	b25b      	sxtb	r3, r3
    11ec:	3301      	adds	r3, #1
    11ee:	d0c9      	beq.n	1184 <xQueueSemaphoreTake+0x80>
    11f0:	2345      	movs	r3, #69	; 0x45
    11f2:	5ce3      	ldrb	r3, [r4, r3]
    11f4:	b25b      	sxtb	r3, r3
    11f6:	3301      	adds	r3, #1
    11f8:	d0c8      	beq.n	118c <xQueueSemaphoreTake+0x88>
    11fa:	4b1e      	ldr	r3, [pc, #120]	; (1274 <xQueueSemaphoreTake+0x170>)
    11fc:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    11fe:	a901      	add	r1, sp, #4
    1200:	a802      	add	r0, sp, #8
    1202:	4b23      	ldr	r3, [pc, #140]	; (1290 <xQueueSemaphoreTake+0x18c>)
    1204:	4798      	blx	r3
    1206:	2800      	cmp	r0, #0
    1208:	d1d3      	bne.n	11b2 <xQueueSemaphoreTake+0xae>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    120a:	0020      	movs	r0, r4
    120c:	4b1e      	ldr	r3, [pc, #120]	; (1288 <xQueueSemaphoreTake+0x184>)
    120e:	4798      	blx	r3
    1210:	2800      	cmp	r0, #0
    1212:	d0c8      	beq.n	11a6 <xQueueSemaphoreTake+0xa2>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1214:	6823      	ldr	r3, [r4, #0]
    1216:	2b00      	cmp	r3, #0
    1218:	d0bc      	beq.n	1194 <xQueueSemaphoreTake+0x90>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    121a:	0020      	movs	r0, r4
    121c:	3024      	adds	r0, #36	; 0x24
    121e:	9901      	ldr	r1, [sp, #4]
    1220:	4b1c      	ldr	r3, [pc, #112]	; (1294 <xQueueSemaphoreTake+0x190>)
    1222:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
    1224:	0020      	movs	r0, r4
    1226:	4b16      	ldr	r3, [pc, #88]	; (1280 <xQueueSemaphoreTake+0x17c>)
    1228:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    122a:	4b16      	ldr	r3, [pc, #88]	; (1284 <xQueueSemaphoreTake+0x180>)
    122c:	4798      	blx	r3
    122e:	2800      	cmp	r0, #0
    1230:	d1c9      	bne.n	11c6 <xQueueSemaphoreTake+0xc2>
					portYIELD_WITHIN_API();
    1232:	4b0f      	ldr	r3, [pc, #60]	; (1270 <xQueueSemaphoreTake+0x16c>)
    1234:	4798      	blx	r3
    1236:	e7c6      	b.n	11c6 <xQueueSemaphoreTake+0xc2>
					if( xInheritanceOccurred != pdFALSE )
    1238:	2d00      	cmp	r5, #0
    123a:	d100      	bne.n	123e <xQueueSemaphoreTake+0x13a>
    123c:	e794      	b.n	1168 <xQueueSemaphoreTake+0x64>
						taskENTER_CRITICAL();
    123e:	4b09      	ldr	r3, [pc, #36]	; (1264 <xQueueSemaphoreTake+0x160>)
    1240:	4798      	blx	r3
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
    1242:	6a63      	ldr	r3, [r4, #36]	; 0x24
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    1244:	2100      	movs	r1, #0
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
    1246:	2b00      	cmp	r3, #0
    1248:	d003      	beq.n	1252 <xQueueSemaphoreTake+0x14e>
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    124a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    124c:	681b      	ldr	r3, [r3, #0]
    124e:	3105      	adds	r1, #5
    1250:	1ac9      	subs	r1, r1, r3
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
    1252:	6860      	ldr	r0, [r4, #4]
    1254:	4b10      	ldr	r3, [pc, #64]	; (1298 <xQueueSemaphoreTake+0x194>)
    1256:	4798      	blx	r3
						taskEXIT_CRITICAL();
    1258:	4b06      	ldr	r3, [pc, #24]	; (1274 <xQueueSemaphoreTake+0x170>)
    125a:	4798      	blx	r3
				return errQUEUE_EMPTY;
    125c:	2500      	movs	r5, #0
    125e:	e783      	b.n	1168 <xQueueSemaphoreTake+0x64>
    1260:	00001c91 	.word	0x00001c91
    1264:	000009f1 	.word	0x000009f1
    1268:	00001e4d 	.word	0x00001e4d
    126c:	00001b89 	.word	0x00001b89
    1270:	000009d9 	.word	0x000009d9
    1274:	00000a09 	.word	0x00000a09
    1278:	00001c09 	.word	0x00001c09
    127c:	00001cad 	.word	0x00001cad
    1280:	00000bdd 	.word	0x00000bdd
    1284:	0000195d 	.word	0x0000195d
    1288:	00000ab5 	.word	0x00000ab5
    128c:	00001831 	.word	0x00001831
    1290:	00001c19 	.word	0x00001c19
    1294:	00001b25 	.word	0x00001b25
    1298:	00001dc1 	.word	0x00001dc1

0000129c <vQueueAddToRegistry>:
	{
    129c:	b510      	push	{r4, lr}
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    129e:	4b0a      	ldr	r3, [pc, #40]	; (12c8 <vQueueAddToRegistry+0x2c>)
    12a0:	681b      	ldr	r3, [r3, #0]
    12a2:	2b00      	cmp	r3, #0
    12a4:	d009      	beq.n	12ba <vQueueAddToRegistry+0x1e>
    12a6:	2301      	movs	r3, #1
    12a8:	4c07      	ldr	r4, [pc, #28]	; (12c8 <vQueueAddToRegistry+0x2c>)
    12aa:	00da      	lsls	r2, r3, #3
    12ac:	58a2      	ldr	r2, [r4, r2]
    12ae:	2a00      	cmp	r2, #0
    12b0:	d004      	beq.n	12bc <vQueueAddToRegistry+0x20>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    12b2:	3301      	adds	r3, #1
    12b4:	2b08      	cmp	r3, #8
    12b6:	d1f8      	bne.n	12aa <vQueueAddToRegistry+0xe>
	}
    12b8:	bd10      	pop	{r4, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    12ba:	2300      	movs	r3, #0
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    12bc:	4a02      	ldr	r2, [pc, #8]	; (12c8 <vQueueAddToRegistry+0x2c>)
    12be:	00db      	lsls	r3, r3, #3
    12c0:	5099      	str	r1, [r3, r2]
				xQueueRegistry[ ux ].xHandle = xQueue;
    12c2:	18d3      	adds	r3, r2, r3
    12c4:	6058      	str	r0, [r3, #4]
				break;
    12c6:	e7f7      	b.n	12b8 <vQueueAddToRegistry+0x1c>
    12c8:	20004450 	.word	0x20004450

000012cc <vQueueWaitForMessageRestricted>:
	{
    12cc:	b570      	push	{r4, r5, r6, lr}
    12ce:	0004      	movs	r4, r0
    12d0:	000d      	movs	r5, r1
    12d2:	0016      	movs	r6, r2
		prvLockQueue( pxQueue );
    12d4:	4b11      	ldr	r3, [pc, #68]	; (131c <vQueueWaitForMessageRestricted+0x50>)
    12d6:	4798      	blx	r3
    12d8:	2344      	movs	r3, #68	; 0x44
    12da:	5ce3      	ldrb	r3, [r4, r3]
    12dc:	b25b      	sxtb	r3, r3
    12de:	3301      	adds	r3, #1
    12e0:	d00d      	beq.n	12fe <vQueueWaitForMessageRestricted+0x32>
    12e2:	2345      	movs	r3, #69	; 0x45
    12e4:	5ce3      	ldrb	r3, [r4, r3]
    12e6:	b25b      	sxtb	r3, r3
    12e8:	3301      	adds	r3, #1
    12ea:	d00c      	beq.n	1306 <vQueueWaitForMessageRestricted+0x3a>
    12ec:	4b0c      	ldr	r3, [pc, #48]	; (1320 <vQueueWaitForMessageRestricted+0x54>)
    12ee:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    12f0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    12f2:	2b00      	cmp	r3, #0
    12f4:	d00b      	beq.n	130e <vQueueWaitForMessageRestricted+0x42>
		prvUnlockQueue( pxQueue );
    12f6:	0020      	movs	r0, r4
    12f8:	4b0a      	ldr	r3, [pc, #40]	; (1324 <vQueueWaitForMessageRestricted+0x58>)
    12fa:	4798      	blx	r3
	}
    12fc:	bd70      	pop	{r4, r5, r6, pc}
		prvLockQueue( pxQueue );
    12fe:	2200      	movs	r2, #0
    1300:	2344      	movs	r3, #68	; 0x44
    1302:	54e2      	strb	r2, [r4, r3]
    1304:	e7ed      	b.n	12e2 <vQueueWaitForMessageRestricted+0x16>
    1306:	2200      	movs	r2, #0
    1308:	2345      	movs	r3, #69	; 0x45
    130a:	54e2      	strb	r2, [r4, r3]
    130c:	e7ee      	b.n	12ec <vQueueWaitForMessageRestricted+0x20>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    130e:	0020      	movs	r0, r4
    1310:	3024      	adds	r0, #36	; 0x24
    1312:	0032      	movs	r2, r6
    1314:	0029      	movs	r1, r5
    1316:	4b04      	ldr	r3, [pc, #16]	; (1328 <vQueueWaitForMessageRestricted+0x5c>)
    1318:	4798      	blx	r3
    131a:	e7ec      	b.n	12f6 <vQueueWaitForMessageRestricted+0x2a>
    131c:	000009f1 	.word	0x000009f1
    1320:	00000a09 	.word	0x00000a09
    1324:	00000bdd 	.word	0x00000bdd
    1328:	00001b51 	.word	0x00001b51

0000132c <sendI2CDataArray>:
#include "RTCControl.h"
#include "sam.h"

volatile uint32_t i;

void sendI2CDataArray(uint8_t SlAddr, uint8_t *ptrData, uint32_t Size){
    132c:	b570      	push	{r4, r5, r6, lr}
	SERCOM3->I2CM.CTRLB.bit.CMD = 0x3;
    132e:	4b1c      	ldr	r3, [pc, #112]	; (13a0 <sendI2CDataArray+0x74>)
    1330:	685d      	ldr	r5, [r3, #4]
    1332:	24c0      	movs	r4, #192	; 0xc0
    1334:	02a4      	lsls	r4, r4, #10
    1336:	432c      	orrs	r4, r5
    1338:	605c      	str	r4, [r3, #4]
	
	/* Acknowledge section is set as ACK signal by writing 0 in ACKACT bit */
	SERCOM3->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    133a:	685c      	ldr	r4, [r3, #4]
    133c:	4d19      	ldr	r5, [pc, #100]	; (13a4 <sendI2CDataArray+0x78>)
    133e:	402c      	ands	r4, r5
    1340:	605c      	str	r4, [r3, #4]
	while(SERCOM3->I2CM.SYNCBUSY.reg); // waiting load
    1342:	001c      	movs	r4, r3
    1344:	69e3      	ldr	r3, [r4, #28]
    1346:	2b00      	cmp	r3, #0
    1348:	d1fc      	bne.n	1344 <sendI2CDataArray+0x18>
	
	/* slave address with write signal (0) */
	SERCOM3->I2CM.ADDR.reg = (SlAddr << 1) | 0;    /* Sending slave address in write mode */
    134a:	0040      	lsls	r0, r0, #1
    134c:	4b14      	ldr	r3, [pc, #80]	; (13a0 <sendI2CDataArray+0x74>)
    134e:	6258      	str	r0, [r3, #36]	; 0x24
	while(SERCOM3->I2CM.INTFLAG.bit.MB == 0);		   /* MB = 1 if slave NACKS the address */
    1350:	0018      	movs	r0, r3
    1352:	7e03      	ldrb	r3, [r0, #24]
    1354:	07db      	lsls	r3, r3, #31
    1356:	d5fc      	bpl.n	1352 <sendI2CDataArray+0x26>
	
	SERCOM3->I2CM.DATA.reg = 0x0;
    1358:	2400      	movs	r4, #0
    135a:	2328      	movs	r3, #40	; 0x28
    135c:	4810      	ldr	r0, [pc, #64]	; (13a0 <sendI2CDataArray+0x74>)
    135e:	54c4      	strb	r4, [r0, r3]
	while(SERCOM3->I2CM.INTFLAG.bit.MB == 0){}; /* MB = 1 if slave NACKS the address */
    1360:	7e03      	ldrb	r3, [r0, #24]
    1362:	07db      	lsls	r3, r3, #31
    1364:	d5fc      	bpl.n	1360 <sendI2CDataArray+0x34>

	for(i = 0; i < Size; i ++) {
    1366:	4b10      	ldr	r3, [pc, #64]	; (13a8 <sendI2CDataArray+0x7c>)
    1368:	2000      	movs	r0, #0
    136a:	6018      	str	r0, [r3, #0]
    136c:	681b      	ldr	r3, [r3, #0]
    136e:	429a      	cmp	r2, r3
    1370:	d90f      	bls.n	1392 <sendI2CDataArray+0x66>
		/* placing the data from transmitting buffer to DATA register*/
		SERCOM3->I2CM.DATA.reg = ptrData[i];
    1372:	4e0d      	ldr	r6, [pc, #52]	; (13a8 <sendI2CDataArray+0x7c>)
    1374:	480a      	ldr	r0, [pc, #40]	; (13a0 <sendI2CDataArray+0x74>)
    1376:	2528      	movs	r5, #40	; 0x28
	for(i = 0; i < Size; i ++) {
    1378:	0034      	movs	r4, r6
		SERCOM3->I2CM.DATA.reg = ptrData[i];
    137a:	6833      	ldr	r3, [r6, #0]
    137c:	5ccb      	ldrb	r3, [r1, r3]
    137e:	5543      	strb	r3, [r0, r5]
		while(SERCOM3->I2CM.INTFLAG.bit.MB == 0){}; /* MB = 1 if slave NACKS the address */
    1380:	7e03      	ldrb	r3, [r0, #24]
    1382:	07db      	lsls	r3, r3, #31
    1384:	d5fc      	bpl.n	1380 <sendI2CDataArray+0x54>
	for(i = 0; i < Size; i ++) {
    1386:	6823      	ldr	r3, [r4, #0]
    1388:	3301      	adds	r3, #1
    138a:	6023      	str	r3, [r4, #0]
    138c:	6823      	ldr	r3, [r4, #0]
    138e:	4293      	cmp	r3, r2
    1390:	d3f3      	bcc.n	137a <sendI2CDataArray+0x4e>
	}

	/* After transferring the last byte stop condition will be sent */
	SERCOM3->I2CM.CTRLB.bit.CMD = 0x3;
    1392:	4a03      	ldr	r2, [pc, #12]	; (13a0 <sendI2CDataArray+0x74>)
    1394:	6851      	ldr	r1, [r2, #4]
    1396:	23c0      	movs	r3, #192	; 0xc0
    1398:	029b      	lsls	r3, r3, #10
    139a:	430b      	orrs	r3, r1
    139c:	6053      	str	r3, [r2, #4]
}
    139e:	bd70      	pop	{r4, r5, r6, pc}
    13a0:	42001400 	.word	0x42001400
    13a4:	fffbffff 	.word	0xfffbffff
    13a8:	20004490 	.word	0x20004490

000013ac <receiveI2CDataArray>:
void StopCond(){
	// Turn off the I2C
	SERCOM3->I2CM.CTRLA.bit.ENABLE = 0x0u;
}

void receiveI2CDataArray(uint8_t SlAddr, uint8_t *ptrData, uint32_t Size){
    13ac:	b5f0      	push	{r4, r5, r6, r7, lr}
	SERCOM3->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    13ae:	4c27      	ldr	r4, [pc, #156]	; (144c <receiveI2CDataArray+0xa0>)
    13b0:	6863      	ldr	r3, [r4, #4]
    13b2:	4d27      	ldr	r5, [pc, #156]	; (1450 <receiveI2CDataArray+0xa4>)
    13b4:	402b      	ands	r3, r5
    13b6:	6063      	str	r3, [r4, #4]
	while(SERCOM3->I2CM.SYNCBUSY.reg); // waiting load
    13b8:	69e3      	ldr	r3, [r4, #28]
    13ba:	2b00      	cmp	r3, #0
    13bc:	d1fc      	bne.n	13b8 <receiveI2CDataArray+0xc>
	/* slave address with write signal (0) */
	SERCOM3->I2CM.ADDR.reg = (SlAddr << 1) | 0;    /* Sending slave address in write mode */
    13be:	0040      	lsls	r0, r0, #1
    13c0:	4b22      	ldr	r3, [pc, #136]	; (144c <receiveI2CDataArray+0xa0>)
    13c2:	6258      	str	r0, [r3, #36]	; 0x24
	while(SERCOM3->I2CM.INTFLAG.bit.MB ==0);		   /* MB = 1 if slave NACKS the address */
    13c4:	001c      	movs	r4, r3
    13c6:	7e23      	ldrb	r3, [r4, #24]
    13c8:	07db      	lsls	r3, r3, #31
    13ca:	d5fc      	bpl.n	13c6 <receiveI2CDataArray+0x1a>
	//	SERCOM3->I2CM.DATA.reg = ;                 /* Sending address (seconds) for internal pointer */
	SERCOM3->I2CM.DATA.reg = 0x00;                     /* Sending address (seconds) for internal pointer */
    13cc:	2500      	movs	r5, #0
    13ce:	2328      	movs	r3, #40	; 0x28
    13d0:	4c1e      	ldr	r4, [pc, #120]	; (144c <receiveI2CDataArray+0xa0>)
    13d2:	54e5      	strb	r5, [r4, r3]
	while(SERCOM3->I2CM.INTFLAG.bit.MB ==0){};         /* MB = 1 if slave NACKS the address */
    13d4:	7e23      	ldrb	r3, [r4, #24]
    13d6:	07db      	lsls	r3, r3, #31
    13d8:	d5fc      	bpl.n	13d4 <receiveI2CDataArray+0x28>
	SERCOM3->I2CM.CTRLB.bit.CMD = 0x3;                 /* Sending stop condition */
    13da:	4b1c      	ldr	r3, [pc, #112]	; (144c <receiveI2CDataArray+0xa0>)
    13dc:	685d      	ldr	r5, [r3, #4]
    13de:	24c0      	movs	r4, #192	; 0xc0
    13e0:	02a4      	lsls	r4, r4, #10
    13e2:	432c      	orrs	r4, r5
    13e4:	605c      	str	r4, [r3, #4]
	
	
	/******************  RECIEVING SEQUENCE  *************************/

	/* slave address with read signal (1) */
	SERCOM3->I2CM.ADDR.reg = (SlAddr << 1) | 1;
    13e6:	2401      	movs	r4, #1
    13e8:	4320      	orrs	r0, r4
    13ea:	6258      	str	r0, [r3, #36]	; 0x24
	while(SERCOM3->I2CM.INTFLAG.bit.SB==0){};
    13ec:	0018      	movs	r0, r3
    13ee:	7e03      	ldrb	r3, [r0, #24]
    13f0:	079b      	lsls	r3, r3, #30
    13f2:	d5fc      	bpl.n	13ee <receiveI2CDataArray+0x42>

	/* Acknowledge section is set as ACK signal by writing 0 in ACKACT bit */
	SERCOM3->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    13f4:	4815      	ldr	r0, [pc, #84]	; (144c <receiveI2CDataArray+0xa0>)
    13f6:	6843      	ldr	r3, [r0, #4]
    13f8:	4c15      	ldr	r4, [pc, #84]	; (1450 <receiveI2CDataArray+0xa4>)
    13fa:	4023      	ands	r3, r4
    13fc:	6043      	str	r3, [r0, #4]

	for(i=0; i< Size; i++) {
    13fe:	4b15      	ldr	r3, [pc, #84]	; (1454 <receiveI2CDataArray+0xa8>)
    1400:	2000      	movs	r0, #0
    1402:	6018      	str	r0, [r3, #0]
    1404:	681b      	ldr	r3, [r3, #0]
    1406:	429a      	cmp	r2, r3
    1408:	d90f      	bls.n	142a <receiveI2CDataArray+0x7e>
		ptrData[i] = SERCOM3->I2CM.DATA.reg;
    140a:	4f12      	ldr	r7, [pc, #72]	; (1454 <receiveI2CDataArray+0xa8>)
    140c:	480f      	ldr	r0, [pc, #60]	; (144c <receiveI2CDataArray+0xa0>)
    140e:	2628      	movs	r6, #40	; 0x28
	for(i=0; i< Size; i++) {
    1410:	003c      	movs	r4, r7
		ptrData[i] = SERCOM3->I2CM.DATA.reg;
    1412:	683b      	ldr	r3, [r7, #0]
    1414:	5d85      	ldrb	r5, [r0, r6]
    1416:	54cd      	strb	r5, [r1, r3]
		while(SERCOM3->I2CM.INTFLAG.bit.SB==0){};
    1418:	7e03      	ldrb	r3, [r0, #24]
    141a:	079b      	lsls	r3, r3, #30
    141c:	d5fc      	bpl.n	1418 <receiveI2CDataArray+0x6c>
	for(i=0; i< Size; i++) {
    141e:	6823      	ldr	r3, [r4, #0]
    1420:	3301      	adds	r3, #1
    1422:	6023      	str	r3, [r4, #0]
    1424:	6823      	ldr	r3, [r4, #0]
    1426:	4293      	cmp	r3, r2
    1428:	d3f3      	bcc.n	1412 <receiveI2CDataArray+0x66>
	}
	/* NACK should be send before reading the last byte*/
	SERCOM3->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    142a:	4b08      	ldr	r3, [pc, #32]	; (144c <receiveI2CDataArray+0xa0>)
    142c:	685c      	ldr	r4, [r3, #4]
    142e:	2080      	movs	r0, #128	; 0x80
    1430:	02c0      	lsls	r0, r0, #11
    1432:	4320      	orrs	r0, r4
    1434:	6058      	str	r0, [r3, #4]
	SERCOM3->I2CM.CTRLB.bit.CMD = 0x3;
    1436:	685c      	ldr	r4, [r3, #4]
    1438:	20c0      	movs	r0, #192	; 0xc0
    143a:	0280      	lsls	r0, r0, #10
    143c:	4320      	orrs	r0, r4
    143e:	6058      	str	r0, [r3, #4]
	ptrData[Size-1] = SERCOM3->I2CM.DATA.reg;
    1440:	2028      	movs	r0, #40	; 0x28
    1442:	5c1b      	ldrb	r3, [r3, r0]
    1444:	1889      	adds	r1, r1, r2
    1446:	3901      	subs	r1, #1
    1448:	700b      	strb	r3, [r1, #0]
}
    144a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    144c:	42001400 	.word	0x42001400
    1450:	fffbffff 	.word	0xfffbffff
    1454:	20004490 	.word	0x20004490

00001458 <initI2C>:

void initI2C(void)
{	
	/* port mux configuration */
	PORT->Group[0].PINCFG[PIN_PA22].reg = PORT_PINCFG_PMUXEN | PORT_PINCFG_INEN | PORT_PINCFG_PULLEN; /* SDA */
    1458:	4b1e      	ldr	r3, [pc, #120]	; (14d4 <initI2C+0x7c>)
    145a:	2207      	movs	r2, #7
    145c:	2156      	movs	r1, #86	; 0x56
    145e:	545a      	strb	r2, [r3, r1]
	PORT->Group[0].PINCFG[PIN_PA23].reg = PORT_PINCFG_PMUXEN | PORT_PINCFG_INEN | PORT_PINCFG_PULLEN; /* SCL */
    1460:	3101      	adds	r1, #1
    1462:	545a      	strb	r2, [r3, r1]
	
	/* PMUX: even = n/2, odd: (n-1)/2 */
	PORT->Group[0].PMUX[11].reg |= 0x02u;
    1464:	3234      	adds	r2, #52	; 0x34
    1466:	5c99      	ldrb	r1, [r3, r2]
    1468:	2002      	movs	r0, #2
    146a:	4301      	orrs	r1, r0
    146c:	5499      	strb	r1, [r3, r2]
	PORT->Group[0].PMUX[11].reg |= 0x20u;
    146e:	5c99      	ldrb	r1, [r3, r2]
    1470:	301e      	adds	r0, #30
    1472:	4301      	orrs	r1, r0
    1474:	5499      	strb	r1, [r3, r2]
	
	/* APBCMASK */
	PM->APBCMASK.reg |= PM_APBCMASK_SERCOM3;
    1476:	4a18      	ldr	r2, [pc, #96]	; (14d8 <initI2C+0x80>)
    1478:	6a13      	ldr	r3, [r2, #32]
    147a:	2120      	movs	r1, #32
    147c:	430b      	orrs	r3, r1
    147e:	6213      	str	r3, [r2, #32]

	/*GCLK configuration for sercom3 module*/
	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID (SERCOM3_GCLK_ID_CORE) |
    1480:	4b16      	ldr	r3, [pc, #88]	; (14dc <initI2C+0x84>)
    1482:	4a17      	ldr	r2, [pc, #92]	; (14e0 <initI2C+0x88>)
    1484:	805a      	strh	r2, [r3, #2]
	GCLK_CLKCTRL_ID (SERCOM3_GCLK_ID_SLOW) |
	GCLK_CLKCTRL_GEN(4) |
	GCLK_CLKCTRL_CLKEN;
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_SRC_OSC8M|GCLK_GENCTRL_GENEN|GCLK_GENCTRL_ID(4);
    1486:	6859      	ldr	r1, [r3, #4]
    1488:	4a16      	ldr	r2, [pc, #88]	; (14e4 <initI2C+0x8c>)
    148a:	430a      	orrs	r2, r1
    148c:	605a      	str	r2, [r3, #4]

	/* set configuration for SERCOM3 I2C module */
	SERCOM3->I2CM.CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN; /* smart mode enable */
    148e:	2280      	movs	r2, #128	; 0x80
    1490:	0052      	lsls	r2, r2, #1
    1492:	4b15      	ldr	r3, [pc, #84]	; (14e8 <initI2C+0x90>)
    1494:	605a      	str	r2, [r3, #4]
	while (SERCOM3->I2CM.SYNCBUSY.reg); // waiting loading
    1496:	001a      	movs	r2, r3
    1498:	69d3      	ldr	r3, [r2, #28]
    149a:	2b00      	cmp	r3, #0
    149c:	d1fc      	bne.n	1498 <initI2C+0x40>
	
	/* calculate BAUDRATE */
	uint64_t tmp_baud =((8000000/100000)-10-(8000000*250 /1000000000))/2;
	SERCOM3->I2CM.BAUD.bit.BAUD = SERCOM_I2CM_BAUD_BAUD((uint32_t)tmp_baud);
    149e:	4a12      	ldr	r2, [pc, #72]	; (14e8 <initI2C+0x90>)
    14a0:	68d3      	ldr	r3, [r2, #12]
    14a2:	21ff      	movs	r1, #255	; 0xff
    14a4:	438b      	bics	r3, r1
    14a6:	39dd      	subs	r1, #221	; 0xdd
    14a8:	430b      	orrs	r3, r1
    14aa:	60d3      	str	r3, [r2, #12]
	while (SERCOM3->I2CM.SYNCBUSY.reg); // waiting loading
    14ac:	69d3      	ldr	r3, [r2, #28]
    14ae:	2b00      	cmp	r3, #0
    14b0:	d1fc      	bne.n	14ac <initI2C+0x54>
	// value equals 0x22 or decimal 34
	
	SERCOM3->I2CM.CTRLA.reg = SERCOM_I2CM_CTRLA_ENABLE   |/* enable module */
    14b2:	4a0e      	ldr	r2, [pc, #56]	; (14ec <initI2C+0x94>)
    14b4:	4b0c      	ldr	r3, [pc, #48]	; (14e8 <initI2C+0x90>)
    14b6:	601a      	str	r2, [r3, #0]
	SERCOM_I2CM_CTRLA_MODE_I2C_MASTER |		/* i2c master mode */
	SERCOM_I2CM_CTRLA_SDAHOLD(3);		 /* SDA hold time to 600ns */
	while (SERCOM3->I2CM.SYNCBUSY.reg);  /* waiting loading */
    14b8:	001a      	movs	r2, r3
    14ba:	69d3      	ldr	r3, [r2, #28]
    14bc:	2b00      	cmp	r3, #0
    14be:	d1fc      	bne.n	14ba <initI2C+0x62>

	SERCOM3->I2CM.STATUS.reg |= SERCOM_I2CM_STATUS_BUSSTATE(1); /* set to idle state */
    14c0:	4a09      	ldr	r2, [pc, #36]	; (14e8 <initI2C+0x90>)
    14c2:	8b53      	ldrh	r3, [r2, #26]
    14c4:	2110      	movs	r1, #16
    14c6:	430b      	orrs	r3, r1
    14c8:	8353      	strh	r3, [r2, #26]
	while (SERCOM3->I2CM.SYNCBUSY.reg);  /* waiting loading */
    14ca:	69d3      	ldr	r3, [r2, #28]
    14cc:	2b00      	cmp	r3, #0
    14ce:	d1fc      	bne.n	14ca <initI2C+0x72>
    14d0:	4770      	bx	lr
    14d2:	46c0      	nop			; (mov r8, r8)
    14d4:	41004400 	.word	0x41004400
    14d8:	40000400 	.word	0x40000400
    14dc:	40000c00 	.word	0x40000c00
    14e0:	00004417 	.word	0x00004417
    14e4:	00010604 	.word	0x00010604
    14e8:	42001400 	.word	0x42001400
    14ec:	00300016 	.word	0x00300016

000014f0 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    14f0:	4b08      	ldr	r3, [pc, #32]	; (1514 <prvResetNextTaskUnblockTime+0x24>)
    14f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    14f4:	681b      	ldr	r3, [r3, #0]
    14f6:	2b00      	cmp	r3, #0
    14f8:	d006      	beq.n	1508 <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    14fa:	4b06      	ldr	r3, [pc, #24]	; (1514 <prvResetNextTaskUnblockTime+0x24>)
    14fc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    14fe:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1500:	68d2      	ldr	r2, [r2, #12]
    1502:	6852      	ldr	r2, [r2, #4]
    1504:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    1506:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
    1508:	2201      	movs	r2, #1
    150a:	4252      	negs	r2, r2
    150c:	4b01      	ldr	r3, [pc, #4]	; (1514 <prvResetNextTaskUnblockTime+0x24>)
    150e:	62da      	str	r2, [r3, #44]	; 0x2c
    1510:	e7f9      	b.n	1506 <prvResetNextTaskUnblockTime+0x16>
    1512:	46c0      	nop			; (mov r8, r8)
    1514:	2000430c 	.word	0x2000430c

00001518 <prvIdleTask>:
{
    1518:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    151a:	46ce      	mov	lr, r9
    151c:	4647      	mov	r7, r8
    151e:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1520:	4b12      	ldr	r3, [pc, #72]	; (156c <prvIdleTask+0x54>)
    1522:	4698      	mov	r8, r3
			taskENTER_CRITICAL();
    1524:	4f12      	ldr	r7, [pc, #72]	; (1570 <prvIdleTask+0x58>)
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1526:	001c      	movs	r4, r3
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1528:	4b12      	ldr	r3, [pc, #72]	; (1574 <prvIdleTask+0x5c>)
    152a:	4699      	mov	r9, r3
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    152c:	4643      	mov	r3, r8
    152e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1530:	2b00      	cmp	r3, #0
    1532:	d014      	beq.n	155e <prvIdleTask+0x46>
			taskENTER_CRITICAL();
    1534:	47b8      	blx	r7
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1536:	6c23      	ldr	r3, [r4, #64]	; 0x40
    1538:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    153a:	1d28      	adds	r0, r5, #4
    153c:	47c8      	blx	r9
				--uxCurrentNumberOfTasks;
    153e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1540:	3b01      	subs	r3, #1
    1542:	64a3      	str	r3, [r4, #72]	; 0x48
				--uxDeletedTasksWaitingCleanUp;
    1544:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1546:	3b01      	subs	r3, #1
    1548:	6323      	str	r3, [r4, #48]	; 0x30
			taskEXIT_CRITICAL();
    154a:	4b0b      	ldr	r3, [pc, #44]	; (1578 <prvIdleTask+0x60>)
    154c:	4798      	blx	r3
			vPortFree( pxTCB->pxStack );
    154e:	6b28      	ldr	r0, [r5, #48]	; 0x30
    1550:	4e0a      	ldr	r6, [pc, #40]	; (157c <prvIdleTask+0x64>)
    1552:	47b0      	blx	r6
			vPortFree( pxTCB );
    1554:	0028      	movs	r0, r5
    1556:	47b0      	blx	r6
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1558:	6b23      	ldr	r3, [r4, #48]	; 0x30
    155a:	2b00      	cmp	r3, #0
    155c:	d1ea      	bne.n	1534 <prvIdleTask+0x1c>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    155e:	4b03      	ldr	r3, [pc, #12]	; (156c <prvIdleTask+0x54>)
    1560:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1562:	2b01      	cmp	r3, #1
    1564:	d9e2      	bls.n	152c <prvIdleTask+0x14>
				taskYIELD();
    1566:	4b06      	ldr	r3, [pc, #24]	; (1580 <prvIdleTask+0x68>)
    1568:	4798      	blx	r3
    156a:	e7df      	b.n	152c <prvIdleTask+0x14>
    156c:	2000430c 	.word	0x2000430c
    1570:	000009f1 	.word	0x000009f1
    1574:	00000383 	.word	0x00000383
    1578:	00000a09 	.word	0x00000a09
    157c:	000002d9 	.word	0x000002d9
    1580:	000009d9 	.word	0x000009d9

00001584 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    1584:	b570      	push	{r4, r5, r6, lr}
    1586:	0004      	movs	r4, r0
    1588:	000d      	movs	r5, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    158a:	4b15      	ldr	r3, [pc, #84]	; (15e0 <prvAddCurrentTaskToDelayedList+0x5c>)
    158c:	6b1e      	ldr	r6, [r3, #48]	; 0x30
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    158e:	6b58      	ldr	r0, [r3, #52]	; 0x34
    1590:	3004      	adds	r0, #4
    1592:	4b14      	ldr	r3, [pc, #80]	; (15e4 <prvAddCurrentTaskToDelayedList+0x60>)
    1594:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    1596:	1c63      	adds	r3, r4, #1
    1598:	d012      	beq.n	15c0 <prvAddCurrentTaskToDelayedList+0x3c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    159a:	1934      	adds	r4, r6, r4

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    159c:	4b10      	ldr	r3, [pc, #64]	; (15e0 <prvAddCurrentTaskToDelayedList+0x5c>)
    159e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    15a0:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
    15a2:	42a6      	cmp	r6, r4
    15a4:	d815      	bhi.n	15d2 <prvAddCurrentTaskToDelayedList+0x4e>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    15a6:	4d10      	ldr	r5, [pc, #64]	; (15e8 <prvAddCurrentTaskToDelayedList+0x64>)
    15a8:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    15aa:	4b0d      	ldr	r3, [pc, #52]	; (15e0 <prvAddCurrentTaskToDelayedList+0x5c>)
    15ac:	6b59      	ldr	r1, [r3, #52]	; 0x34
    15ae:	3104      	adds	r1, #4
    15b0:	4b0e      	ldr	r3, [pc, #56]	; (15ec <prvAddCurrentTaskToDelayedList+0x68>)
    15b2:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    15b4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    15b6:	429c      	cmp	r4, r3
    15b8:	d211      	bcs.n	15de <prvAddCurrentTaskToDelayedList+0x5a>
				{
					xNextTaskUnblockTime = xTimeToWake;
    15ba:	4b0b      	ldr	r3, [pc, #44]	; (15e8 <prvAddCurrentTaskToDelayedList+0x64>)
    15bc:	62dc      	str	r4, [r3, #44]	; 0x2c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    15be:	e00e      	b.n	15de <prvAddCurrentTaskToDelayedList+0x5a>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    15c0:	2d00      	cmp	r5, #0
    15c2:	d0ea      	beq.n	159a <prvAddCurrentTaskToDelayedList+0x16>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    15c4:	4b06      	ldr	r3, [pc, #24]	; (15e0 <prvAddCurrentTaskToDelayedList+0x5c>)
    15c6:	6b59      	ldr	r1, [r3, #52]	; 0x34
    15c8:	3104      	adds	r1, #4
    15ca:	4807      	ldr	r0, [pc, #28]	; (15e8 <prvAddCurrentTaskToDelayedList+0x64>)
    15cc:	4b08      	ldr	r3, [pc, #32]	; (15f0 <prvAddCurrentTaskToDelayedList+0x6c>)
    15ce:	4798      	blx	r3
    15d0:	e005      	b.n	15de <prvAddCurrentTaskToDelayedList+0x5a>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    15d2:	4b03      	ldr	r3, [pc, #12]	; (15e0 <prvAddCurrentTaskToDelayedList+0x5c>)
    15d4:	6b98      	ldr	r0, [r3, #56]	; 0x38
    15d6:	6b59      	ldr	r1, [r3, #52]	; 0x34
    15d8:	3104      	adds	r1, #4
    15da:	4b04      	ldr	r3, [pc, #16]	; (15ec <prvAddCurrentTaskToDelayedList+0x68>)
    15dc:	4798      	blx	r3
}
    15de:	bd70      	pop	{r4, r5, r6, pc}
    15e0:	2000438c 	.word	0x2000438c
    15e4:	00000383 	.word	0x00000383
    15e8:	2000430c 	.word	0x2000430c
    15ec:	00000355 	.word	0x00000355
    15f0:	0000033d 	.word	0x0000033d

000015f4 <xTaskCreate>:
	{
    15f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    15f6:	46d6      	mov	lr, sl
    15f8:	464f      	mov	r7, r9
    15fa:	4646      	mov	r6, r8
    15fc:	b5c0      	push	{r6, r7, lr}
    15fe:	b084      	sub	sp, #16
    1600:	9001      	str	r0, [sp, #4]
    1602:	000d      	movs	r5, r1
    1604:	9302      	str	r3, [sp, #8]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1606:	0097      	lsls	r7, r2, #2
    1608:	0038      	movs	r0, r7
    160a:	4b63      	ldr	r3, [pc, #396]	; (1798 <xTaskCreate+0x1a4>)
    160c:	4798      	blx	r3
    160e:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
    1610:	d100      	bne.n	1614 <xTaskCreate+0x20>
    1612:	e089      	b.n	1728 <xTaskCreate+0x134>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1614:	2054      	movs	r0, #84	; 0x54
    1616:	4b60      	ldr	r3, [pc, #384]	; (1798 <xTaskCreate+0x1a4>)
    1618:	4798      	blx	r3
    161a:	1e04      	subs	r4, r0, #0
				if( pxNewTCB != NULL )
    161c:	d100      	bne.n	1620 <xTaskCreate+0x2c>
    161e:	e080      	b.n	1722 <xTaskCreate+0x12e>
					pxNewTCB->pxStack = pxStack;
    1620:	6306      	str	r6, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    1622:	003a      	movs	r2, r7
    1624:	21a5      	movs	r1, #165	; 0xa5
    1626:	0030      	movs	r0, r6
    1628:	4b5c      	ldr	r3, [pc, #368]	; (179c <xTaskCreate+0x1a8>)
    162a:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    162c:	1f3a      	subs	r2, r7, #4
    162e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1630:	469c      	mov	ip, r3
    1632:	4462      	add	r2, ip
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    1634:	2307      	movs	r3, #7
    1636:	439a      	bics	r2, r3
    1638:	4690      	mov	r8, r2
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    163a:	782a      	ldrb	r2, [r5, #0]
    163c:	332d      	adds	r3, #45	; 0x2d
    163e:	54e2      	strb	r2, [r4, r3]
		if( pcName[ x ] == 0x00 )
    1640:	782b      	ldrb	r3, [r5, #0]
    1642:	2b00      	cmp	r3, #0
    1644:	d00c      	beq.n	1660 <xTaskCreate+0x6c>
    1646:	1c6b      	adds	r3, r5, #1
    1648:	0022      	movs	r2, r4
    164a:	3235      	adds	r2, #53	; 0x35
    164c:	3505      	adds	r5, #5
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    164e:	7819      	ldrb	r1, [r3, #0]
    1650:	7011      	strb	r1, [r2, #0]
		if( pcName[ x ] == 0x00 )
    1652:	7819      	ldrb	r1, [r3, #0]
    1654:	2900      	cmp	r1, #0
    1656:	d003      	beq.n	1660 <xTaskCreate+0x6c>
    1658:	3301      	adds	r3, #1
    165a:	3201      	adds	r2, #1
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    165c:	42ab      	cmp	r3, r5
    165e:	d1f6      	bne.n	164e <xTaskCreate+0x5a>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1660:	2200      	movs	r2, #0
    1662:	2338      	movs	r3, #56	; 0x38
    1664:	54e2      	strb	r2, [r4, r3]
    1666:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    1668:	2f04      	cmp	r7, #4
    166a:	d900      	bls.n	166e <xTaskCreate+0x7a>
    166c:	2704      	movs	r7, #4
	pxNewTCB->uxPriority = uxPriority;
    166e:	62e7      	str	r7, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    1670:	6467      	str	r7, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
    1672:	2600      	movs	r6, #0
    1674:	64a6      	str	r6, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1676:	1d23      	adds	r3, r4, #4
    1678:	9303      	str	r3, [sp, #12]
    167a:	0018      	movs	r0, r3
    167c:	4d48      	ldr	r5, [pc, #288]	; (17a0 <xTaskCreate+0x1ac>)
    167e:	47a8      	blx	r5
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1680:	0020      	movs	r0, r4
    1682:	3018      	adds	r0, #24
    1684:	47a8      	blx	r5
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1686:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1688:	2305      	movs	r3, #5
    168a:	1bdb      	subs	r3, r3, r7
    168c:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    168e:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    1690:	64e6      	str	r6, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1692:	2350      	movs	r3, #80	; 0x50
    1694:	54e6      	strb	r6, [r4, r3]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1696:	9a02      	ldr	r2, [sp, #8]
    1698:	9901      	ldr	r1, [sp, #4]
    169a:	4640      	mov	r0, r8
    169c:	4b41      	ldr	r3, [pc, #260]	; (17a4 <xTaskCreate+0x1b0>)
    169e:	4798      	blx	r3
    16a0:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
    16a2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    16a4:	2b00      	cmp	r3, #0
    16a6:	d000      	beq.n	16aa <xTaskCreate+0xb6>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    16a8:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
    16aa:	4b3f      	ldr	r3, [pc, #252]	; (17a8 <xTaskCreate+0x1b4>)
    16ac:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    16ae:	4a3f      	ldr	r2, [pc, #252]	; (17ac <xTaskCreate+0x1b8>)
    16b0:	6c93      	ldr	r3, [r2, #72]	; 0x48
    16b2:	3301      	adds	r3, #1
    16b4:	6493      	str	r3, [r2, #72]	; 0x48
		if( pxCurrentTCB == NULL )
    16b6:	4b3e      	ldr	r3, [pc, #248]	; (17b0 <xTaskCreate+0x1bc>)
    16b8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    16ba:	2b00      	cmp	r3, #0
    16bc:	d037      	beq.n	172e <xTaskCreate+0x13a>
			if( xSchedulerRunning == pdFALSE )
    16be:	4b3c      	ldr	r3, [pc, #240]	; (17b0 <xTaskCreate+0x1bc>)
    16c0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    16c2:	2b00      	cmp	r3, #0
    16c4:	d107      	bne.n	16d6 <xTaskCreate+0xe2>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    16c6:	4b3a      	ldr	r3, [pc, #232]	; (17b0 <xTaskCreate+0x1bc>)
    16c8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    16ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    16cc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    16ce:	4293      	cmp	r3, r2
    16d0:	d801      	bhi.n	16d6 <xTaskCreate+0xe2>
					pxCurrentTCB = pxNewTCB;
    16d2:	4b37      	ldr	r3, [pc, #220]	; (17b0 <xTaskCreate+0x1bc>)
    16d4:	635c      	str	r4, [r3, #52]	; 0x34
		uxTaskNumber++;
    16d6:	4936      	ldr	r1, [pc, #216]	; (17b0 <xTaskCreate+0x1bc>)
    16d8:	6e8b      	ldr	r3, [r1, #104]	; 0x68
    16da:	3301      	adds	r3, #1
    16dc:	668b      	str	r3, [r1, #104]	; 0x68
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    16de:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList( pxNewTCB );
    16e0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    16e2:	6ecb      	ldr	r3, [r1, #108]	; 0x6c
    16e4:	429a      	cmp	r2, r3
    16e6:	d900      	bls.n	16ea <xTaskCreate+0xf6>
    16e8:	66ca      	str	r2, [r1, #108]	; 0x6c
    16ea:	0090      	lsls	r0, r2, #2
    16ec:	1882      	adds	r2, r0, r2
    16ee:	0092      	lsls	r2, r2, #2
    16f0:	482e      	ldr	r0, [pc, #184]	; (17ac <xTaskCreate+0x1b8>)
    16f2:	304c      	adds	r0, #76	; 0x4c
    16f4:	1880      	adds	r0, r0, r2
    16f6:	9903      	ldr	r1, [sp, #12]
    16f8:	4b2e      	ldr	r3, [pc, #184]	; (17b4 <xTaskCreate+0x1c0>)
    16fa:	4798      	blx	r3
	taskEXIT_CRITICAL();
    16fc:	4b2e      	ldr	r3, [pc, #184]	; (17b8 <xTaskCreate+0x1c4>)
    16fe:	4798      	blx	r3
	if( xSchedulerRunning != pdFALSE )
    1700:	4b2b      	ldr	r3, [pc, #172]	; (17b0 <xTaskCreate+0x1bc>)
    1702:	6e5b      	ldr	r3, [r3, #100]	; 0x64
			xReturn = pdPASS;
    1704:	2001      	movs	r0, #1
	if( xSchedulerRunning != pdFALSE )
    1706:	2b00      	cmp	r3, #0
    1708:	d005      	beq.n	1716 <xTaskCreate+0x122>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    170a:	4b29      	ldr	r3, [pc, #164]	; (17b0 <xTaskCreate+0x1bc>)
    170c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    170e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1710:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1712:	429a      	cmp	r2, r3
    1714:	d33b      	bcc.n	178e <xTaskCreate+0x19a>
	}
    1716:	b004      	add	sp, #16
    1718:	bc1c      	pop	{r2, r3, r4}
    171a:	4690      	mov	r8, r2
    171c:	4699      	mov	r9, r3
    171e:	46a2      	mov	sl, r4
    1720:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
    1722:	0030      	movs	r0, r6
    1724:	4b25      	ldr	r3, [pc, #148]	; (17bc <xTaskCreate+0x1c8>)
    1726:	4798      	blx	r3
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1728:	2001      	movs	r0, #1
    172a:	4240      	negs	r0, r0
    172c:	e7f3      	b.n	1716 <xTaskCreate+0x122>
			pxCurrentTCB = pxNewTCB;
    172e:	4b20      	ldr	r3, [pc, #128]	; (17b0 <xTaskCreate+0x1bc>)
    1730:	635c      	str	r4, [r3, #52]	; 0x34
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1732:	6c93      	ldr	r3, [r2, #72]	; 0x48
    1734:	2b01      	cmp	r3, #1
    1736:	d1ce      	bne.n	16d6 <xTaskCreate+0xe2>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1738:	0017      	movs	r7, r2
    173a:	0010      	movs	r0, r2
    173c:	304c      	adds	r0, #76	; 0x4c
    173e:	4e20      	ldr	r6, [pc, #128]	; (17c0 <xTaskCreate+0x1cc>)
    1740:	47b0      	blx	r6
    1742:	0038      	movs	r0, r7
    1744:	3060      	adds	r0, #96	; 0x60
    1746:	47b0      	blx	r6
    1748:	0038      	movs	r0, r7
    174a:	3074      	adds	r0, #116	; 0x74
    174c:	47b0      	blx	r6
    174e:	0038      	movs	r0, r7
    1750:	3088      	adds	r0, #136	; 0x88
    1752:	47b0      	blx	r6
    1754:	0038      	movs	r0, r7
    1756:	309c      	adds	r0, #156	; 0x9c
    1758:	47b0      	blx	r6
	vListInitialise( &xDelayedTaskList1 );
    175a:	4b15      	ldr	r3, [pc, #84]	; (17b0 <xTaskCreate+0x1bc>)
    175c:	4698      	mov	r8, r3
    175e:	233c      	movs	r3, #60	; 0x3c
    1760:	4443      	add	r3, r8
    1762:	469a      	mov	sl, r3
    1764:	0018      	movs	r0, r3
    1766:	47b0      	blx	r6
	vListInitialise( &xDelayedTaskList2 );
    1768:	2350      	movs	r3, #80	; 0x50
    176a:	4443      	add	r3, r8
    176c:	4699      	mov	r9, r3
    176e:	0018      	movs	r0, r3
    1770:	47b0      	blx	r6
	vListInitialise( &xPendingReadyList );
    1772:	0038      	movs	r0, r7
    1774:	3014      	adds	r0, #20
    1776:	47b0      	blx	r6
		vListInitialise( &xTasksWaitingTermination );
    1778:	0038      	movs	r0, r7
    177a:	3034      	adds	r0, #52	; 0x34
    177c:	47b0      	blx	r6
		vListInitialise( &xSuspendedTaskList );
    177e:	0038      	movs	r0, r7
    1780:	47b0      	blx	r6
	pxDelayedTaskList = &xDelayedTaskList1;
    1782:	4653      	mov	r3, sl
    1784:	62bb      	str	r3, [r7, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1786:	4643      	mov	r3, r8
    1788:	464a      	mov	r2, r9
    178a:	639a      	str	r2, [r3, #56]	; 0x38
    178c:	e7a3      	b.n	16d6 <xTaskCreate+0xe2>
			taskYIELD_IF_USING_PREEMPTION();
    178e:	4b0d      	ldr	r3, [pc, #52]	; (17c4 <xTaskCreate+0x1d0>)
    1790:	4798      	blx	r3
			xReturn = pdPASS;
    1792:	2001      	movs	r0, #1
    1794:	e7bf      	b.n	1716 <xTaskCreate+0x122>
    1796:	46c0      	nop			; (mov r8, r8)
    1798:	0000020d 	.word	0x0000020d
    179c:	00002359 	.word	0x00002359
    17a0:	00000337 	.word	0x00000337
    17a4:	00000955 	.word	0x00000955
    17a8:	000009f1 	.word	0x000009f1
    17ac:	2000430c 	.word	0x2000430c
    17b0:	2000438c 	.word	0x2000438c
    17b4:	0000033d 	.word	0x0000033d
    17b8:	00000a09 	.word	0x00000a09
    17bc:	000002d9 	.word	0x000002d9
    17c0:	00000321 	.word	0x00000321
    17c4:	000009d9 	.word	0x000009d9

000017c8 <vTaskStartScheduler>:
{
    17c8:	b510      	push	{r4, lr}
    17ca:	b082      	sub	sp, #8
		xReturn = xTaskCreate(	prvIdleTask,
    17cc:	4b11      	ldr	r3, [pc, #68]	; (1814 <vTaskStartScheduler+0x4c>)
    17ce:	3374      	adds	r3, #116	; 0x74
    17d0:	9301      	str	r3, [sp, #4]
    17d2:	2300      	movs	r3, #0
    17d4:	9300      	str	r3, [sp, #0]
    17d6:	2246      	movs	r2, #70	; 0x46
    17d8:	490f      	ldr	r1, [pc, #60]	; (1818 <vTaskStartScheduler+0x50>)
    17da:	4810      	ldr	r0, [pc, #64]	; (181c <vTaskStartScheduler+0x54>)
    17dc:	4c10      	ldr	r4, [pc, #64]	; (1820 <vTaskStartScheduler+0x58>)
    17de:	47a0      	blx	r4
		if( xReturn == pdPASS )
    17e0:	2801      	cmp	r0, #1
    17e2:	d003      	beq.n	17ec <vTaskStartScheduler+0x24>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    17e4:	1c43      	adds	r3, r0, #1
    17e6:	d012      	beq.n	180e <vTaskStartScheduler+0x46>
}
    17e8:	b002      	add	sp, #8
    17ea:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
    17ec:	4b0d      	ldr	r3, [pc, #52]	; (1824 <vTaskStartScheduler+0x5c>)
    17ee:	4798      	blx	r3
	if( xReturn == pdPASS )
    17f0:	2801      	cmp	r0, #1
    17f2:	d1f7      	bne.n	17e4 <vTaskStartScheduler+0x1c>
		portDISABLE_INTERRUPTS();
    17f4:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
    17f6:	2201      	movs	r2, #1
    17f8:	4252      	negs	r2, r2
    17fa:	4b0b      	ldr	r3, [pc, #44]	; (1828 <vTaskStartScheduler+0x60>)
    17fc:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning = pdTRUE;
    17fe:	4b05      	ldr	r3, [pc, #20]	; (1814 <vTaskStartScheduler+0x4c>)
    1800:	3202      	adds	r2, #2
    1802:	665a      	str	r2, [r3, #100]	; 0x64
		xTickCount = ( TickType_t ) 0U;
    1804:	2200      	movs	r2, #0
    1806:	631a      	str	r2, [r3, #48]	; 0x30
		if( xPortStartScheduler() != pdFALSE )
    1808:	4b08      	ldr	r3, [pc, #32]	; (182c <vTaskStartScheduler+0x64>)
    180a:	4798      	blx	r3
    180c:	e7ec      	b.n	17e8 <vTaskStartScheduler+0x20>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    180e:	b672      	cpsid	i
    1810:	e7fe      	b.n	1810 <vTaskStartScheduler+0x48>
    1812:	46c0      	nop			; (mov r8, r8)
    1814:	2000438c 	.word	0x2000438c
    1818:	000025c0 	.word	0x000025c0
    181c:	00001519 	.word	0x00001519
    1820:	000015f5 	.word	0x000015f5
    1824:	00001f0d 	.word	0x00001f0d
    1828:	2000430c 	.word	0x2000430c
    182c:	00000975 	.word	0x00000975

00001830 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    1830:	4a02      	ldr	r2, [pc, #8]	; (183c <vTaskSuspendAll+0xc>)
    1832:	6f13      	ldr	r3, [r2, #112]	; 0x70
    1834:	3301      	adds	r3, #1
    1836:	6713      	str	r3, [r2, #112]	; 0x70
}
    1838:	4770      	bx	lr
    183a:	46c0      	nop			; (mov r8, r8)
    183c:	2000438c 	.word	0x2000438c

00001840 <xTaskGetTickCount>:
		xTicks = xTickCount;
    1840:	4b01      	ldr	r3, [pc, #4]	; (1848 <xTaskGetTickCount+0x8>)
    1842:	6b18      	ldr	r0, [r3, #48]	; 0x30
}
    1844:	4770      	bx	lr
    1846:	46c0      	nop			; (mov r8, r8)
    1848:	2000438c 	.word	0x2000438c

0000184c <xTaskIncrementTick>:
{
    184c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    184e:	46ce      	mov	lr, r9
    1850:	4647      	mov	r7, r8
    1852:	b580      	push	{r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1854:	4b3b      	ldr	r3, [pc, #236]	; (1944 <xTaskIncrementTick+0xf8>)
    1856:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1858:	2b00      	cmp	r3, #0
    185a:	d164      	bne.n	1926 <xTaskIncrementTick+0xda>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    185c:	4b39      	ldr	r3, [pc, #228]	; (1944 <xTaskIncrementTick+0xf8>)
    185e:	6b1e      	ldr	r6, [r3, #48]	; 0x30
    1860:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
    1862:	631e      	str	r6, [r3, #48]	; 0x30
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    1864:	2e00      	cmp	r6, #0
    1866:	d111      	bne.n	188c <xTaskIncrementTick+0x40>
			taskSWITCH_DELAYED_LISTS();
    1868:	4b37      	ldr	r3, [pc, #220]	; (1948 <xTaskIncrementTick+0xfc>)
    186a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    186c:	681b      	ldr	r3, [r3, #0]
    186e:	2b00      	cmp	r3, #0
    1870:	d001      	beq.n	1876 <xTaskIncrementTick+0x2a>
    1872:	b672      	cpsid	i
    1874:	e7fe      	b.n	1874 <xTaskIncrementTick+0x28>
    1876:	4a34      	ldr	r2, [pc, #208]	; (1948 <xTaskIncrementTick+0xfc>)
    1878:	6a91      	ldr	r1, [r2, #40]	; 0x28
    187a:	4b32      	ldr	r3, [pc, #200]	; (1944 <xTaskIncrementTick+0xf8>)
    187c:	6b98      	ldr	r0, [r3, #56]	; 0x38
    187e:	6290      	str	r0, [r2, #40]	; 0x28
    1880:	6399      	str	r1, [r3, #56]	; 0x38
    1882:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    1884:	3201      	adds	r2, #1
    1886:	679a      	str	r2, [r3, #120]	; 0x78
    1888:	4b30      	ldr	r3, [pc, #192]	; (194c <xTaskIncrementTick+0x100>)
    188a:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
    188c:	4b2e      	ldr	r3, [pc, #184]	; (1948 <xTaskIncrementTick+0xfc>)
    188e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
BaseType_t xSwitchRequired = pdFALSE;
    1890:	2400      	movs	r4, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
    1892:	429e      	cmp	r6, r3
    1894:	d337      	bcc.n	1906 <xTaskIncrementTick+0xba>
    1896:	2400      	movs	r4, #0
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1898:	4b2b      	ldr	r3, [pc, #172]	; (1948 <xTaskIncrementTick+0xfc>)
    189a:	4699      	mov	r9, r3
					prvAddTaskToReadyList( pxTCB );
    189c:	224c      	movs	r2, #76	; 0x4c
    189e:	4694      	mov	ip, r2
    18a0:	4463      	add	r3, ip
    18a2:	4698      	mov	r8, r3
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    18a4:	464b      	mov	r3, r9
    18a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    18a8:	681b      	ldr	r3, [r3, #0]
    18aa:	2b00      	cmp	r3, #0
    18ac:	d027      	beq.n	18fe <xTaskIncrementTick+0xb2>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    18ae:	4b26      	ldr	r3, [pc, #152]	; (1948 <xTaskIncrementTick+0xfc>)
    18b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    18b2:	68db      	ldr	r3, [r3, #12]
    18b4:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    18b6:	687b      	ldr	r3, [r7, #4]
					if( xConstTickCount < xItemValue )
    18b8:	429e      	cmp	r6, r3
    18ba:	d331      	bcc.n	1920 <xTaskIncrementTick+0xd4>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    18bc:	1d3d      	adds	r5, r7, #4
    18be:	0028      	movs	r0, r5
    18c0:	4b23      	ldr	r3, [pc, #140]	; (1950 <xTaskIncrementTick+0x104>)
    18c2:	4798      	blx	r3
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    18c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    18c6:	2b00      	cmp	r3, #0
    18c8:	d003      	beq.n	18d2 <xTaskIncrementTick+0x86>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    18ca:	0038      	movs	r0, r7
    18cc:	3018      	adds	r0, #24
    18ce:	4b20      	ldr	r3, [pc, #128]	; (1950 <xTaskIncrementTick+0x104>)
    18d0:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
    18d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    18d4:	4a1b      	ldr	r2, [pc, #108]	; (1944 <xTaskIncrementTick+0xf8>)
    18d6:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    18d8:	4293      	cmp	r3, r2
    18da:	d901      	bls.n	18e0 <xTaskIncrementTick+0x94>
    18dc:	4a19      	ldr	r2, [pc, #100]	; (1944 <xTaskIncrementTick+0xf8>)
    18de:	66d3      	str	r3, [r2, #108]	; 0x6c
    18e0:	0098      	lsls	r0, r3, #2
    18e2:	18c0      	adds	r0, r0, r3
    18e4:	0080      	lsls	r0, r0, #2
    18e6:	4440      	add	r0, r8
    18e8:	0029      	movs	r1, r5
    18ea:	4b1a      	ldr	r3, [pc, #104]	; (1954 <xTaskIncrementTick+0x108>)
    18ec:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    18ee:	4b15      	ldr	r3, [pc, #84]	; (1944 <xTaskIncrementTick+0xf8>)
    18f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    18f2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    18f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    18f6:	429a      	cmp	r2, r3
    18f8:	d3d4      	bcc.n	18a4 <xTaskIncrementTick+0x58>
							xSwitchRequired = pdTRUE;
    18fa:	2401      	movs	r4, #1
    18fc:	e7d2      	b.n	18a4 <xTaskIncrementTick+0x58>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    18fe:	2201      	movs	r2, #1
    1900:	4252      	negs	r2, r2
    1902:	4b11      	ldr	r3, [pc, #68]	; (1948 <xTaskIncrementTick+0xfc>)
    1904:	62da      	str	r2, [r3, #44]	; 0x2c
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1906:	4b0f      	ldr	r3, [pc, #60]	; (1944 <xTaskIncrementTick+0xf8>)
    1908:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    190a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    190c:	0093      	lsls	r3, r2, #2
    190e:	189b      	adds	r3, r3, r2
    1910:	009b      	lsls	r3, r3, #2
    1912:	4a0d      	ldr	r2, [pc, #52]	; (1948 <xTaskIncrementTick+0xfc>)
    1914:	18d3      	adds	r3, r2, r3
    1916:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1918:	2b01      	cmp	r3, #1
    191a:	d909      	bls.n	1930 <xTaskIncrementTick+0xe4>
				xSwitchRequired = pdTRUE;
    191c:	2401      	movs	r4, #1
    191e:	e007      	b.n	1930 <xTaskIncrementTick+0xe4>
						xNextTaskUnblockTime = xItemValue;
    1920:	4a09      	ldr	r2, [pc, #36]	; (1948 <xTaskIncrementTick+0xfc>)
    1922:	62d3      	str	r3, [r2, #44]	; 0x2c
						break;
    1924:	e7ef      	b.n	1906 <xTaskIncrementTick+0xba>
		++uxPendedTicks;
    1926:	4a07      	ldr	r2, [pc, #28]	; (1944 <xTaskIncrementTick+0xf8>)
    1928:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
    192a:	3301      	adds	r3, #1
    192c:	67d3      	str	r3, [r2, #124]	; 0x7c
BaseType_t xSwitchRequired = pdFALSE;
    192e:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
    1930:	4b09      	ldr	r3, [pc, #36]	; (1958 <xTaskIncrementTick+0x10c>)
    1932:	681b      	ldr	r3, [r3, #0]
    1934:	2b00      	cmp	r3, #0
    1936:	d000      	beq.n	193a <xTaskIncrementTick+0xee>
			xSwitchRequired = pdTRUE;
    1938:	2401      	movs	r4, #1
}
    193a:	0020      	movs	r0, r4
    193c:	bc0c      	pop	{r2, r3}
    193e:	4690      	mov	r8, r2
    1940:	4699      	mov	r9, r3
    1942:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1944:	2000438c 	.word	0x2000438c
    1948:	2000430c 	.word	0x2000430c
    194c:	000014f1 	.word	0x000014f1
    1950:	00000383 	.word	0x00000383
    1954:	0000033d 	.word	0x0000033d
    1958:	2000440c 	.word	0x2000440c

0000195c <xTaskResumeAll>:
{
    195c:	b5f0      	push	{r4, r5, r6, r7, lr}
    195e:	b083      	sub	sp, #12
	configASSERT( uxSchedulerSuspended );
    1960:	4b31      	ldr	r3, [pc, #196]	; (1a28 <xTaskResumeAll+0xcc>)
    1962:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1964:	2b00      	cmp	r3, #0
    1966:	d101      	bne.n	196c <xTaskResumeAll+0x10>
    1968:	b672      	cpsid	i
    196a:	e7fe      	b.n	196a <xTaskResumeAll+0xe>
	taskENTER_CRITICAL();
    196c:	4b2f      	ldr	r3, [pc, #188]	; (1a2c <xTaskResumeAll+0xd0>)
    196e:	4798      	blx	r3
		--uxSchedulerSuspended;
    1970:	4b2d      	ldr	r3, [pc, #180]	; (1a28 <xTaskResumeAll+0xcc>)
    1972:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    1974:	3a01      	subs	r2, #1
    1976:	671a      	str	r2, [r3, #112]	; 0x70
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1978:	6f1b      	ldr	r3, [r3, #112]	; 0x70
BaseType_t xAlreadyYielded = pdFALSE;
    197a:	2400      	movs	r4, #0
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    197c:	2b00      	cmp	r3, #0
    197e:	d104      	bne.n	198a <xTaskResumeAll+0x2e>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1980:	4b2b      	ldr	r3, [pc, #172]	; (1a30 <xTaskResumeAll+0xd4>)
    1982:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1984:	2500      	movs	r5, #0
    1986:	2b00      	cmp	r3, #0
    1988:	d104      	bne.n	1994 <xTaskResumeAll+0x38>
	taskEXIT_CRITICAL();
    198a:	4b2a      	ldr	r3, [pc, #168]	; (1a34 <xTaskResumeAll+0xd8>)
    198c:	4798      	blx	r3
}
    198e:	0020      	movs	r0, r4
    1990:	b003      	add	sp, #12
    1992:	bdf0      	pop	{r4, r5, r6, r7, pc}
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1994:	4f26      	ldr	r7, [pc, #152]	; (1a30 <xTaskResumeAll+0xd4>)
					prvAddTaskToReadyList( pxTCB );
    1996:	003e      	movs	r6, r7
    1998:	364c      	adds	r6, #76	; 0x4c
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    199a:	697b      	ldr	r3, [r7, #20]
    199c:	2b00      	cmp	r3, #0
    199e:	d022      	beq.n	19e6 <xTaskResumeAll+0x8a>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    19a0:	4b23      	ldr	r3, [pc, #140]	; (1a30 <xTaskResumeAll+0xd4>)
    19a2:	6a1b      	ldr	r3, [r3, #32]
    19a4:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    19a6:	0028      	movs	r0, r5
    19a8:	3018      	adds	r0, #24
    19aa:	4c23      	ldr	r4, [pc, #140]	; (1a38 <xTaskResumeAll+0xdc>)
    19ac:	47a0      	blx	r4
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    19ae:	1d2b      	adds	r3, r5, #4
    19b0:	9301      	str	r3, [sp, #4]
    19b2:	0018      	movs	r0, r3
    19b4:	47a0      	blx	r4
					prvAddTaskToReadyList( pxTCB );
    19b6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    19b8:	4a1b      	ldr	r2, [pc, #108]	; (1a28 <xTaskResumeAll+0xcc>)
    19ba:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    19bc:	4293      	cmp	r3, r2
    19be:	d901      	bls.n	19c4 <xTaskResumeAll+0x68>
    19c0:	4a19      	ldr	r2, [pc, #100]	; (1a28 <xTaskResumeAll+0xcc>)
    19c2:	66d3      	str	r3, [r2, #108]	; 0x6c
    19c4:	0098      	lsls	r0, r3, #2
    19c6:	18c0      	adds	r0, r0, r3
    19c8:	0080      	lsls	r0, r0, #2
    19ca:	1830      	adds	r0, r6, r0
    19cc:	9901      	ldr	r1, [sp, #4]
    19ce:	4b1b      	ldr	r3, [pc, #108]	; (1a3c <xTaskResumeAll+0xe0>)
    19d0:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    19d2:	4b15      	ldr	r3, [pc, #84]	; (1a28 <xTaskResumeAll+0xcc>)
    19d4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    19d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    19d8:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    19da:	429a      	cmp	r2, r3
    19dc:	d3dd      	bcc.n	199a <xTaskResumeAll+0x3e>
						xYieldPending = pdTRUE;
    19de:	2201      	movs	r2, #1
    19e0:	4b17      	ldr	r3, [pc, #92]	; (1a40 <xTaskResumeAll+0xe4>)
    19e2:	601a      	str	r2, [r3, #0]
    19e4:	e7d9      	b.n	199a <xTaskResumeAll+0x3e>
				if( pxTCB != NULL )
    19e6:	2d00      	cmp	r5, #0
    19e8:	d001      	beq.n	19ee <xTaskResumeAll+0x92>
					prvResetNextTaskUnblockTime();
    19ea:	4b16      	ldr	r3, [pc, #88]	; (1a44 <xTaskResumeAll+0xe8>)
    19ec:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    19ee:	4b0e      	ldr	r3, [pc, #56]	; (1a28 <xTaskResumeAll+0xcc>)
    19f0:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
					if( uxPendedCounts > ( UBaseType_t ) 0U )
    19f2:	2c00      	cmp	r4, #0
    19f4:	d00e      	beq.n	1a14 <xTaskResumeAll+0xb8>
							if( xTaskIncrementTick() != pdFALSE )
    19f6:	4f14      	ldr	r7, [pc, #80]	; (1a48 <xTaskResumeAll+0xec>)
								xYieldPending = pdTRUE;
    19f8:	4e11      	ldr	r6, [pc, #68]	; (1a40 <xTaskResumeAll+0xe4>)
    19fa:	2501      	movs	r5, #1
    19fc:	e002      	b.n	1a04 <xTaskResumeAll+0xa8>
							--uxPendedCounts;
    19fe:	3c01      	subs	r4, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1a00:	2c00      	cmp	r4, #0
    1a02:	d004      	beq.n	1a0e <xTaskResumeAll+0xb2>
							if( xTaskIncrementTick() != pdFALSE )
    1a04:	47b8      	blx	r7
    1a06:	2800      	cmp	r0, #0
    1a08:	d0f9      	beq.n	19fe <xTaskResumeAll+0xa2>
								xYieldPending = pdTRUE;
    1a0a:	6035      	str	r5, [r6, #0]
    1a0c:	e7f7      	b.n	19fe <xTaskResumeAll+0xa2>
						uxPendedTicks = 0;
    1a0e:	2200      	movs	r2, #0
    1a10:	4b05      	ldr	r3, [pc, #20]	; (1a28 <xTaskResumeAll+0xcc>)
    1a12:	67da      	str	r2, [r3, #124]	; 0x7c
				if( xYieldPending != pdFALSE )
    1a14:	4b0a      	ldr	r3, [pc, #40]	; (1a40 <xTaskResumeAll+0xe4>)
    1a16:	681b      	ldr	r3, [r3, #0]
BaseType_t xAlreadyYielded = pdFALSE;
    1a18:	2400      	movs	r4, #0
				if( xYieldPending != pdFALSE )
    1a1a:	2b00      	cmp	r3, #0
    1a1c:	d0b5      	beq.n	198a <xTaskResumeAll+0x2e>
					taskYIELD_IF_USING_PREEMPTION();
    1a1e:	4b0b      	ldr	r3, [pc, #44]	; (1a4c <xTaskResumeAll+0xf0>)
    1a20:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    1a22:	3401      	adds	r4, #1
    1a24:	e7b1      	b.n	198a <xTaskResumeAll+0x2e>
    1a26:	46c0      	nop			; (mov r8, r8)
    1a28:	2000438c 	.word	0x2000438c
    1a2c:	000009f1 	.word	0x000009f1
    1a30:	2000430c 	.word	0x2000430c
    1a34:	00000a09 	.word	0x00000a09
    1a38:	00000383 	.word	0x00000383
    1a3c:	0000033d 	.word	0x0000033d
    1a40:	2000440c 	.word	0x2000440c
    1a44:	000014f1 	.word	0x000014f1
    1a48:	0000184d 	.word	0x0000184d
    1a4c:	000009d9 	.word	0x000009d9

00001a50 <vTaskDelay>:
	{
    1a50:	b510      	push	{r4, lr}
    1a52:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
    1a54:	d00f      	beq.n	1a76 <vTaskDelay+0x26>
			configASSERT( uxSchedulerSuspended == 0 );
    1a56:	4b09      	ldr	r3, [pc, #36]	; (1a7c <vTaskDelay+0x2c>)
    1a58:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1a5a:	2b00      	cmp	r3, #0
    1a5c:	d001      	beq.n	1a62 <vTaskDelay+0x12>
    1a5e:	b672      	cpsid	i
    1a60:	e7fe      	b.n	1a60 <vTaskDelay+0x10>
			vTaskSuspendAll();
    1a62:	4b07      	ldr	r3, [pc, #28]	; (1a80 <vTaskDelay+0x30>)
    1a64:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    1a66:	2100      	movs	r1, #0
    1a68:	0020      	movs	r0, r4
    1a6a:	4b06      	ldr	r3, [pc, #24]	; (1a84 <vTaskDelay+0x34>)
    1a6c:	4798      	blx	r3
			xAlreadyYielded = xTaskResumeAll();
    1a6e:	4b06      	ldr	r3, [pc, #24]	; (1a88 <vTaskDelay+0x38>)
    1a70:	4798      	blx	r3
		if( xAlreadyYielded == pdFALSE )
    1a72:	2800      	cmp	r0, #0
    1a74:	d101      	bne.n	1a7a <vTaskDelay+0x2a>
			portYIELD_WITHIN_API();
    1a76:	4b05      	ldr	r3, [pc, #20]	; (1a8c <vTaskDelay+0x3c>)
    1a78:	4798      	blx	r3
	}
    1a7a:	bd10      	pop	{r4, pc}
    1a7c:	2000438c 	.word	0x2000438c
    1a80:	00001831 	.word	0x00001831
    1a84:	00001585 	.word	0x00001585
    1a88:	0000195d 	.word	0x0000195d
    1a8c:	000009d9 	.word	0x000009d9

00001a90 <vTaskSwitchContext>:
{
    1a90:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1a92:	4b21      	ldr	r3, [pc, #132]	; (1b18 <vTaskSwitchContext+0x88>)
    1a94:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1a96:	2b00      	cmp	r3, #0
    1a98:	d11a      	bne.n	1ad0 <vTaskSwitchContext+0x40>
		xYieldPending = pdFALSE;
    1a9a:	2200      	movs	r2, #0
    1a9c:	4b1f      	ldr	r3, [pc, #124]	; (1b1c <vTaskSwitchContext+0x8c>)
    1a9e:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1aa0:	4b1d      	ldr	r3, [pc, #116]	; (1b18 <vTaskSwitchContext+0x88>)
    1aa2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    1aa4:	009a      	lsls	r2, r3, #2
    1aa6:	18d2      	adds	r2, r2, r3
    1aa8:	0092      	lsls	r2, r2, #2
    1aaa:	491d      	ldr	r1, [pc, #116]	; (1b20 <vTaskSwitchContext+0x90>)
    1aac:	188a      	adds	r2, r1, r2
    1aae:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    1ab0:	2a00      	cmp	r2, #0
    1ab2:	d111      	bne.n	1ad8 <vTaskSwitchContext+0x48>
    1ab4:	2b00      	cmp	r3, #0
    1ab6:	d009      	beq.n	1acc <vTaskSwitchContext+0x3c>
    1ab8:	3b01      	subs	r3, #1
    1aba:	009a      	lsls	r2, r3, #2
    1abc:	18d2      	adds	r2, r2, r3
    1abe:	0092      	lsls	r2, r2, #2
    1ac0:	188a      	adds	r2, r1, r2
    1ac2:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    1ac4:	2a00      	cmp	r2, #0
    1ac6:	d107      	bne.n	1ad8 <vTaskSwitchContext+0x48>
    1ac8:	2b00      	cmp	r3, #0
    1aca:	d1f5      	bne.n	1ab8 <vTaskSwitchContext+0x28>
    1acc:	b672      	cpsid	i
    1ace:	e7fe      	b.n	1ace <vTaskSwitchContext+0x3e>
		xYieldPending = pdTRUE;
    1ad0:	2201      	movs	r2, #1
    1ad2:	4b12      	ldr	r3, [pc, #72]	; (1b1c <vTaskSwitchContext+0x8c>)
    1ad4:	601a      	str	r2, [r3, #0]
}
    1ad6:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1ad8:	4a11      	ldr	r2, [pc, #68]	; (1b20 <vTaskSwitchContext+0x90>)
    1ada:	0099      	lsls	r1, r3, #2
    1adc:	18c8      	adds	r0, r1, r3
    1ade:	0080      	lsls	r0, r0, #2
    1ae0:	1810      	adds	r0, r2, r0
    1ae2:	6d04      	ldr	r4, [r0, #80]	; 0x50
    1ae4:	6864      	ldr	r4, [r4, #4]
    1ae6:	6504      	str	r4, [r0, #80]	; 0x50
    1ae8:	18c9      	adds	r1, r1, r3
    1aea:	0089      	lsls	r1, r1, #2
    1aec:	0002      	movs	r2, r0
    1aee:	3254      	adds	r2, #84	; 0x54
    1af0:	4294      	cmp	r4, r2
    1af2:	d00a      	beq.n	1b0a <vTaskSwitchContext+0x7a>
    1af4:	009a      	lsls	r2, r3, #2
    1af6:	18d2      	adds	r2, r2, r3
    1af8:	0092      	lsls	r2, r2, #2
    1afa:	4909      	ldr	r1, [pc, #36]	; (1b20 <vTaskSwitchContext+0x90>)
    1afc:	188a      	adds	r2, r1, r2
    1afe:	6d12      	ldr	r2, [r2, #80]	; 0x50
    1b00:	68d1      	ldr	r1, [r2, #12]
    1b02:	4a05      	ldr	r2, [pc, #20]	; (1b18 <vTaskSwitchContext+0x88>)
    1b04:	6351      	str	r1, [r2, #52]	; 0x34
    1b06:	66d3      	str	r3, [r2, #108]	; 0x6c
}
    1b08:	e7e5      	b.n	1ad6 <vTaskSwitchContext+0x46>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1b0a:	6860      	ldr	r0, [r4, #4]
    1b0c:	000a      	movs	r2, r1
    1b0e:	4904      	ldr	r1, [pc, #16]	; (1b20 <vTaskSwitchContext+0x90>)
    1b10:	188a      	adds	r2, r1, r2
    1b12:	6510      	str	r0, [r2, #80]	; 0x50
    1b14:	e7ee      	b.n	1af4 <vTaskSwitchContext+0x64>
    1b16:	46c0      	nop			; (mov r8, r8)
    1b18:	2000438c 	.word	0x2000438c
    1b1c:	2000440c 	.word	0x2000440c
    1b20:	2000430c 	.word	0x2000430c

00001b24 <vTaskPlaceOnEventList>:
{
    1b24:	b510      	push	{r4, lr}
    1b26:	000c      	movs	r4, r1
	configASSERT( pxEventList );
    1b28:	2800      	cmp	r0, #0
    1b2a:	d101      	bne.n	1b30 <vTaskPlaceOnEventList+0xc>
    1b2c:	b672      	cpsid	i
    1b2e:	e7fe      	b.n	1b2e <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1b30:	4b04      	ldr	r3, [pc, #16]	; (1b44 <vTaskPlaceOnEventList+0x20>)
    1b32:	6b59      	ldr	r1, [r3, #52]	; 0x34
    1b34:	3118      	adds	r1, #24
    1b36:	4b04      	ldr	r3, [pc, #16]	; (1b48 <vTaskPlaceOnEventList+0x24>)
    1b38:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1b3a:	2101      	movs	r1, #1
    1b3c:	0020      	movs	r0, r4
    1b3e:	4b03      	ldr	r3, [pc, #12]	; (1b4c <vTaskPlaceOnEventList+0x28>)
    1b40:	4798      	blx	r3
}
    1b42:	bd10      	pop	{r4, pc}
    1b44:	2000438c 	.word	0x2000438c
    1b48:	00000355 	.word	0x00000355
    1b4c:	00001585 	.word	0x00001585

00001b50 <vTaskPlaceOnEventListRestricted>:
	{
    1b50:	b570      	push	{r4, r5, r6, lr}
    1b52:	000c      	movs	r4, r1
    1b54:	0015      	movs	r5, r2
		configASSERT( pxEventList );
    1b56:	2800      	cmp	r0, #0
    1b58:	d00d      	beq.n	1b76 <vTaskPlaceOnEventListRestricted+0x26>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1b5a:	4b08      	ldr	r3, [pc, #32]	; (1b7c <vTaskPlaceOnEventListRestricted+0x2c>)
    1b5c:	6b59      	ldr	r1, [r3, #52]	; 0x34
    1b5e:	3118      	adds	r1, #24
    1b60:	4b07      	ldr	r3, [pc, #28]	; (1b80 <vTaskPlaceOnEventListRestricted+0x30>)
    1b62:	4798      	blx	r3
		if( xWaitIndefinitely != pdFALSE )
    1b64:	2d00      	cmp	r5, #0
    1b66:	d001      	beq.n	1b6c <vTaskPlaceOnEventListRestricted+0x1c>
			xTicksToWait = portMAX_DELAY;
    1b68:	2401      	movs	r4, #1
    1b6a:	4264      	negs	r4, r4
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    1b6c:	0029      	movs	r1, r5
    1b6e:	0020      	movs	r0, r4
    1b70:	4b04      	ldr	r3, [pc, #16]	; (1b84 <vTaskPlaceOnEventListRestricted+0x34>)
    1b72:	4798      	blx	r3
	}
    1b74:	bd70      	pop	{r4, r5, r6, pc}
		configASSERT( pxEventList );
    1b76:	b672      	cpsid	i
    1b78:	e7fe      	b.n	1b78 <vTaskPlaceOnEventListRestricted+0x28>
    1b7a:	46c0      	nop			; (mov r8, r8)
    1b7c:	2000438c 	.word	0x2000438c
    1b80:	0000033d 	.word	0x0000033d
    1b84:	00001585 	.word	0x00001585

00001b88 <xTaskRemoveFromEventList>:
{
    1b88:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1b8a:	68c3      	ldr	r3, [r0, #12]
    1b8c:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
    1b8e:	2c00      	cmp	r4, #0
    1b90:	d028      	beq.n	1be4 <xTaskRemoveFromEventList+0x5c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1b92:	0025      	movs	r5, r4
    1b94:	3518      	adds	r5, #24
    1b96:	0028      	movs	r0, r5
    1b98:	4b16      	ldr	r3, [pc, #88]	; (1bf4 <xTaskRemoveFromEventList+0x6c>)
    1b9a:	4798      	blx	r3
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1b9c:	4b16      	ldr	r3, [pc, #88]	; (1bf8 <xTaskRemoveFromEventList+0x70>)
    1b9e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1ba0:	2b00      	cmp	r3, #0
    1ba2:	d121      	bne.n	1be8 <xTaskRemoveFromEventList+0x60>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1ba4:	1d25      	adds	r5, r4, #4
    1ba6:	0028      	movs	r0, r5
    1ba8:	4b12      	ldr	r3, [pc, #72]	; (1bf4 <xTaskRemoveFromEventList+0x6c>)
    1baa:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
    1bac:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1bae:	4a12      	ldr	r2, [pc, #72]	; (1bf8 <xTaskRemoveFromEventList+0x70>)
    1bb0:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    1bb2:	4293      	cmp	r3, r2
    1bb4:	d901      	bls.n	1bba <xTaskRemoveFromEventList+0x32>
    1bb6:	4a10      	ldr	r2, [pc, #64]	; (1bf8 <xTaskRemoveFromEventList+0x70>)
    1bb8:	66d3      	str	r3, [r2, #108]	; 0x6c
    1bba:	0098      	lsls	r0, r3, #2
    1bbc:	18c3      	adds	r3, r0, r3
    1bbe:	009b      	lsls	r3, r3, #2
    1bc0:	480e      	ldr	r0, [pc, #56]	; (1bfc <xTaskRemoveFromEventList+0x74>)
    1bc2:	304c      	adds	r0, #76	; 0x4c
    1bc4:	18c0      	adds	r0, r0, r3
    1bc6:	0029      	movs	r1, r5
    1bc8:	4b0d      	ldr	r3, [pc, #52]	; (1c00 <xTaskRemoveFromEventList+0x78>)
    1bca:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1bcc:	4b0a      	ldr	r3, [pc, #40]	; (1bf8 <xTaskRemoveFromEventList+0x70>)
    1bce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1bd0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1bd2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		xReturn = pdFALSE;
    1bd4:	2000      	movs	r0, #0
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1bd6:	429a      	cmp	r2, r3
    1bd8:	d903      	bls.n	1be2 <xTaskRemoveFromEventList+0x5a>
		xYieldPending = pdTRUE;
    1bda:	2201      	movs	r2, #1
    1bdc:	4b09      	ldr	r3, [pc, #36]	; (1c04 <xTaskRemoveFromEventList+0x7c>)
    1bde:	601a      	str	r2, [r3, #0]
		xReturn = pdTRUE;
    1be0:	3001      	adds	r0, #1
}
    1be2:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxUnblockedTCB );
    1be4:	b672      	cpsid	i
    1be6:	e7fe      	b.n	1be6 <xTaskRemoveFromEventList+0x5e>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1be8:	0029      	movs	r1, r5
    1bea:	4804      	ldr	r0, [pc, #16]	; (1bfc <xTaskRemoveFromEventList+0x74>)
    1bec:	3014      	adds	r0, #20
    1bee:	4b04      	ldr	r3, [pc, #16]	; (1c00 <xTaskRemoveFromEventList+0x78>)
    1bf0:	4798      	blx	r3
    1bf2:	e7eb      	b.n	1bcc <xTaskRemoveFromEventList+0x44>
    1bf4:	00000383 	.word	0x00000383
    1bf8:	2000438c 	.word	0x2000438c
    1bfc:	2000430c 	.word	0x2000430c
    1c00:	0000033d 	.word	0x0000033d
    1c04:	2000440c 	.word	0x2000440c

00001c08 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1c08:	4b02      	ldr	r3, [pc, #8]	; (1c14 <vTaskInternalSetTimeOutState+0xc>)
    1c0a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    1c0c:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    1c0e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1c10:	6043      	str	r3, [r0, #4]
}
    1c12:	4770      	bx	lr
    1c14:	2000438c 	.word	0x2000438c

00001c18 <xTaskCheckForTimeOut>:
{
    1c18:	b570      	push	{r4, r5, r6, lr}
    1c1a:	0006      	movs	r6, r0
    1c1c:	000d      	movs	r5, r1
	configASSERT( pxTimeOut );
    1c1e:	2800      	cmp	r0, #0
    1c20:	d01b      	beq.n	1c5a <xTaskCheckForTimeOut+0x42>
	configASSERT( pxTicksToWait );
    1c22:	2900      	cmp	r1, #0
    1c24:	d01b      	beq.n	1c5e <xTaskCheckForTimeOut+0x46>
	taskENTER_CRITICAL();
    1c26:	4b13      	ldr	r3, [pc, #76]	; (1c74 <xTaskCheckForTimeOut+0x5c>)
    1c28:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    1c2a:	4b13      	ldr	r3, [pc, #76]	; (1c78 <xTaskCheckForTimeOut+0x60>)
    1c2c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1c2e:	6871      	ldr	r1, [r6, #4]
			if( *pxTicksToWait == portMAX_DELAY )
    1c30:	682b      	ldr	r3, [r5, #0]
    1c32:	1c58      	adds	r0, r3, #1
    1c34:	d01c      	beq.n	1c70 <xTaskCheckForTimeOut+0x58>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1c36:	4810      	ldr	r0, [pc, #64]	; (1c78 <xTaskCheckForTimeOut+0x60>)
    1c38:	6f80      	ldr	r0, [r0, #120]	; 0x78
    1c3a:	6834      	ldr	r4, [r6, #0]
    1c3c:	4284      	cmp	r4, r0
    1c3e:	d002      	beq.n	1c46 <xTaskCheckForTimeOut+0x2e>
			xReturn = pdTRUE;
    1c40:	2401      	movs	r4, #1
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1c42:	428a      	cmp	r2, r1
    1c44:	d205      	bcs.n	1c52 <xTaskCheckForTimeOut+0x3a>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1c46:	1a52      	subs	r2, r2, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1c48:	429a      	cmp	r2, r3
    1c4a:	d30a      	bcc.n	1c62 <xTaskCheckForTimeOut+0x4a>
			*pxTicksToWait = 0;
    1c4c:	2300      	movs	r3, #0
    1c4e:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
    1c50:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
    1c52:	4b0a      	ldr	r3, [pc, #40]	; (1c7c <xTaskCheckForTimeOut+0x64>)
    1c54:	4798      	blx	r3
}
    1c56:	0020      	movs	r0, r4
    1c58:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxTimeOut );
    1c5a:	b672      	cpsid	i
    1c5c:	e7fe      	b.n	1c5c <xTaskCheckForTimeOut+0x44>
	configASSERT( pxTicksToWait );
    1c5e:	b672      	cpsid	i
    1c60:	e7fe      	b.n	1c60 <xTaskCheckForTimeOut+0x48>
			*pxTicksToWait -= xElapsedTime;
    1c62:	1a9b      	subs	r3, r3, r2
    1c64:	602b      	str	r3, [r5, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
    1c66:	0030      	movs	r0, r6
    1c68:	4b05      	ldr	r3, [pc, #20]	; (1c80 <xTaskCheckForTimeOut+0x68>)
    1c6a:	4798      	blx	r3
			xReturn = pdFALSE;
    1c6c:	2400      	movs	r4, #0
    1c6e:	e7f0      	b.n	1c52 <xTaskCheckForTimeOut+0x3a>
				xReturn = pdFALSE;
    1c70:	2400      	movs	r4, #0
    1c72:	e7ee      	b.n	1c52 <xTaskCheckForTimeOut+0x3a>
    1c74:	000009f1 	.word	0x000009f1
    1c78:	2000438c 	.word	0x2000438c
    1c7c:	00000a09 	.word	0x00000a09
    1c80:	00001c09 	.word	0x00001c09

00001c84 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    1c84:	2201      	movs	r2, #1
    1c86:	4b01      	ldr	r3, [pc, #4]	; (1c8c <vTaskMissedYield+0x8>)
    1c88:	601a      	str	r2, [r3, #0]
}
    1c8a:	4770      	bx	lr
    1c8c:	2000440c 	.word	0x2000440c

00001c90 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
    1c90:	4b05      	ldr	r3, [pc, #20]	; (1ca8 <xTaskGetSchedulerState+0x18>)
    1c92:	6e5b      	ldr	r3, [r3, #100]	; 0x64
			xReturn = taskSCHEDULER_NOT_STARTED;
    1c94:	2001      	movs	r0, #1
		if( xSchedulerRunning == pdFALSE )
    1c96:	2b00      	cmp	r3, #0
    1c98:	d004      	beq.n	1ca4 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1c9a:	4b03      	ldr	r3, [pc, #12]	; (1ca8 <xTaskGetSchedulerState+0x18>)
    1c9c:	6f18      	ldr	r0, [r3, #112]	; 0x70
				xReturn = taskSCHEDULER_SUSPENDED;
    1c9e:	4243      	negs	r3, r0
    1ca0:	4158      	adcs	r0, r3
    1ca2:	0040      	lsls	r0, r0, #1
	}
    1ca4:	4770      	bx	lr
    1ca6:	46c0      	nop			; (mov r8, r8)
    1ca8:	2000438c 	.word	0x2000438c

00001cac <xTaskPriorityInherit>:
	{
    1cac:	b570      	push	{r4, r5, r6, lr}
    1cae:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
    1cb0:	d03d      	beq.n	1d2e <xTaskPriorityInherit+0x82>
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    1cb2:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
    1cb4:	4b1f      	ldr	r3, [pc, #124]	; (1d34 <xTaskPriorityInherit+0x88>)
    1cb6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1cb8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1cba:	4299      	cmp	r1, r3
    1cbc:	d22f      	bcs.n	1d1e <xTaskPriorityInherit+0x72>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1cbe:	6983      	ldr	r3, [r0, #24]
    1cc0:	2b00      	cmp	r3, #0
    1cc2:	db05      	blt.n	1cd0 <xTaskPriorityInherit+0x24>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1cc4:	4b1b      	ldr	r3, [pc, #108]	; (1d34 <xTaskPriorityInherit+0x88>)
    1cc6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1cc8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1cca:	2305      	movs	r3, #5
    1ccc:	1a9b      	subs	r3, r3, r2
    1cce:	6183      	str	r3, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    1cd0:	008b      	lsls	r3, r1, #2
    1cd2:	1859      	adds	r1, r3, r1
    1cd4:	0089      	lsls	r1, r1, #2
    1cd6:	4b18      	ldr	r3, [pc, #96]	; (1d38 <xTaskPriorityInherit+0x8c>)
    1cd8:	334c      	adds	r3, #76	; 0x4c
    1cda:	185b      	adds	r3, r3, r1
    1cdc:	6962      	ldr	r2, [r4, #20]
    1cde:	429a      	cmp	r2, r3
    1ce0:	d005      	beq.n	1cee <xTaskPriorityInherit+0x42>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    1ce2:	4b14      	ldr	r3, [pc, #80]	; (1d34 <xTaskPriorityInherit+0x88>)
    1ce4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1ce6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1ce8:	62e3      	str	r3, [r4, #44]	; 0x2c
				xReturn = pdTRUE;
    1cea:	2001      	movs	r0, #1
    1cec:	e01e      	b.n	1d2c <xTaskPriorityInherit+0x80>
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1cee:	1d25      	adds	r5, r4, #4
    1cf0:	0028      	movs	r0, r5
    1cf2:	4b12      	ldr	r3, [pc, #72]	; (1d3c <xTaskPriorityInherit+0x90>)
    1cf4:	4798      	blx	r3
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    1cf6:	4b0f      	ldr	r3, [pc, #60]	; (1d34 <xTaskPriorityInherit+0x88>)
    1cf8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    1cfa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    1cfc:	62e2      	str	r2, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
    1cfe:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    1d00:	429a      	cmp	r2, r3
    1d02:	d901      	bls.n	1d08 <xTaskPriorityInherit+0x5c>
    1d04:	4b0b      	ldr	r3, [pc, #44]	; (1d34 <xTaskPriorityInherit+0x88>)
    1d06:	66da      	str	r2, [r3, #108]	; 0x6c
    1d08:	0090      	lsls	r0, r2, #2
    1d0a:	1882      	adds	r2, r0, r2
    1d0c:	0092      	lsls	r2, r2, #2
    1d0e:	480a      	ldr	r0, [pc, #40]	; (1d38 <xTaskPriorityInherit+0x8c>)
    1d10:	304c      	adds	r0, #76	; 0x4c
    1d12:	1880      	adds	r0, r0, r2
    1d14:	0029      	movs	r1, r5
    1d16:	4b0a      	ldr	r3, [pc, #40]	; (1d40 <xTaskPriorityInherit+0x94>)
    1d18:	4798      	blx	r3
				xReturn = pdTRUE;
    1d1a:	2001      	movs	r0, #1
    1d1c:	e006      	b.n	1d2c <xTaskPriorityInherit+0x80>
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    1d1e:	4b05      	ldr	r3, [pc, #20]	; (1d34 <xTaskPriorityInherit+0x88>)
    1d20:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1d22:	6c40      	ldr	r0, [r0, #68]	; 0x44
    1d24:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1d26:	4298      	cmp	r0, r3
    1d28:	4180      	sbcs	r0, r0
    1d2a:	4240      	negs	r0, r0
	}
    1d2c:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t xReturn = pdFALSE;
    1d2e:	2000      	movs	r0, #0
		return xReturn;
    1d30:	e7fc      	b.n	1d2c <xTaskPriorityInherit+0x80>
    1d32:	46c0      	nop			; (mov r8, r8)
    1d34:	2000438c 	.word	0x2000438c
    1d38:	2000430c 	.word	0x2000430c
    1d3c:	00000383 	.word	0x00000383
    1d40:	0000033d 	.word	0x0000033d

00001d44 <xTaskPriorityDisinherit>:
	{
    1d44:	b570      	push	{r4, r5, r6, lr}
    1d46:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
    1d48:	d02d      	beq.n	1da6 <xTaskPriorityDisinherit+0x62>
			configASSERT( pxTCB == pxCurrentTCB );
    1d4a:	4b19      	ldr	r3, [pc, #100]	; (1db0 <xTaskPriorityDisinherit+0x6c>)
    1d4c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1d4e:	4298      	cmp	r0, r3
    1d50:	d001      	beq.n	1d56 <xTaskPriorityDisinherit+0x12>
    1d52:	b672      	cpsid	i
    1d54:	e7fe      	b.n	1d54 <xTaskPriorityDisinherit+0x10>
			configASSERT( pxTCB->uxMutexesHeld );
    1d56:	6c83      	ldr	r3, [r0, #72]	; 0x48
    1d58:	2b00      	cmp	r3, #0
    1d5a:	d101      	bne.n	1d60 <xTaskPriorityDisinherit+0x1c>
    1d5c:	b672      	cpsid	i
    1d5e:	e7fe      	b.n	1d5e <xTaskPriorityDisinherit+0x1a>
			( pxTCB->uxMutexesHeld )--;
    1d60:	3b01      	subs	r3, #1
    1d62:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1d64:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    1d66:	6c41      	ldr	r1, [r0, #68]	; 0x44
    1d68:	428a      	cmp	r2, r1
    1d6a:	d01e      	beq.n	1daa <xTaskPriorityDisinherit+0x66>
	BaseType_t xReturn = pdFALSE;
    1d6c:	2000      	movs	r0, #0
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1d6e:	2b00      	cmp	r3, #0
    1d70:	d118      	bne.n	1da4 <xTaskPriorityDisinherit+0x60>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1d72:	1d25      	adds	r5, r4, #4
    1d74:	0028      	movs	r0, r5
    1d76:	4b0f      	ldr	r3, [pc, #60]	; (1db4 <xTaskPriorityDisinherit+0x70>)
    1d78:	4798      	blx	r3
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1d7a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    1d7c:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1d7e:	2205      	movs	r2, #5
    1d80:	1ad2      	subs	r2, r2, r3
    1d82:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
    1d84:	4a0a      	ldr	r2, [pc, #40]	; (1db0 <xTaskPriorityDisinherit+0x6c>)
    1d86:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    1d88:	4293      	cmp	r3, r2
    1d8a:	d901      	bls.n	1d90 <xTaskPriorityDisinherit+0x4c>
    1d8c:	4a08      	ldr	r2, [pc, #32]	; (1db0 <xTaskPriorityDisinherit+0x6c>)
    1d8e:	66d3      	str	r3, [r2, #108]	; 0x6c
    1d90:	0098      	lsls	r0, r3, #2
    1d92:	18c3      	adds	r3, r0, r3
    1d94:	009b      	lsls	r3, r3, #2
    1d96:	4808      	ldr	r0, [pc, #32]	; (1db8 <xTaskPriorityDisinherit+0x74>)
    1d98:	304c      	adds	r0, #76	; 0x4c
    1d9a:	18c0      	adds	r0, r0, r3
    1d9c:	0029      	movs	r1, r5
    1d9e:	4b07      	ldr	r3, [pc, #28]	; (1dbc <xTaskPriorityDisinherit+0x78>)
    1da0:	4798      	blx	r3
					xReturn = pdTRUE;
    1da2:	2001      	movs	r0, #1
	}
    1da4:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t xReturn = pdFALSE;
    1da6:	2000      	movs	r0, #0
    1da8:	e7fc      	b.n	1da4 <xTaskPriorityDisinherit+0x60>
    1daa:	2000      	movs	r0, #0
    1dac:	e7fa      	b.n	1da4 <xTaskPriorityDisinherit+0x60>
    1dae:	46c0      	nop			; (mov r8, r8)
    1db0:	2000438c 	.word	0x2000438c
    1db4:	00000383 	.word	0x00000383
    1db8:	2000430c 	.word	0x2000430c
    1dbc:	0000033d 	.word	0x0000033d

00001dc0 <vTaskPriorityDisinheritAfterTimeout>:
	{
    1dc0:	b570      	push	{r4, r5, r6, lr}
    1dc2:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
    1dc4:	d00d      	beq.n	1de2 <vTaskPriorityDisinheritAfterTimeout+0x22>
			configASSERT( pxTCB->uxMutexesHeld );
    1dc6:	6c83      	ldr	r3, [r0, #72]	; 0x48
    1dc8:	2b00      	cmp	r3, #0
    1dca:	d101      	bne.n	1dd0 <vTaskPriorityDisinheritAfterTimeout+0x10>
    1dcc:	b672      	cpsid	i
    1dce:	e7fe      	b.n	1dce <vTaskPriorityDisinheritAfterTimeout+0xe>
    1dd0:	6c40      	ldr	r0, [r0, #68]	; 0x44
    1dd2:	4288      	cmp	r0, r1
    1dd4:	d200      	bcs.n	1dd8 <vTaskPriorityDisinheritAfterTimeout+0x18>
    1dd6:	0008      	movs	r0, r1
			if( pxTCB->uxPriority != uxPriorityToUse )
    1dd8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1dda:	4282      	cmp	r2, r0
    1ddc:	d001      	beq.n	1de2 <vTaskPriorityDisinheritAfterTimeout+0x22>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    1dde:	2b01      	cmp	r3, #1
    1de0:	d000      	beq.n	1de4 <vTaskPriorityDisinheritAfterTimeout+0x24>
	}
    1de2:	bd70      	pop	{r4, r5, r6, pc}
					configASSERT( pxTCB != pxCurrentTCB );
    1de4:	4b15      	ldr	r3, [pc, #84]	; (1e3c <vTaskPriorityDisinheritAfterTimeout+0x7c>)
    1de6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1de8:	429c      	cmp	r4, r3
    1dea:	d101      	bne.n	1df0 <vTaskPriorityDisinheritAfterTimeout+0x30>
    1dec:	b672      	cpsid	i
    1dee:	e7fe      	b.n	1dee <vTaskPriorityDisinheritAfterTimeout+0x2e>
					pxTCB->uxPriority = uxPriorityToUse;
    1df0:	62e0      	str	r0, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1df2:	69a3      	ldr	r3, [r4, #24]
    1df4:	2b00      	cmp	r3, #0
    1df6:	db02      	blt.n	1dfe <vTaskPriorityDisinheritAfterTimeout+0x3e>
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1df8:	2305      	movs	r3, #5
    1dfa:	1a18      	subs	r0, r3, r0
    1dfc:	61a0      	str	r0, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    1dfe:	0093      	lsls	r3, r2, #2
    1e00:	189a      	adds	r2, r3, r2
    1e02:	0092      	lsls	r2, r2, #2
    1e04:	4b0e      	ldr	r3, [pc, #56]	; (1e40 <vTaskPriorityDisinheritAfterTimeout+0x80>)
    1e06:	334c      	adds	r3, #76	; 0x4c
    1e08:	189b      	adds	r3, r3, r2
    1e0a:	6962      	ldr	r2, [r4, #20]
    1e0c:	429a      	cmp	r2, r3
    1e0e:	d1e8      	bne.n	1de2 <vTaskPriorityDisinheritAfterTimeout+0x22>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1e10:	1d25      	adds	r5, r4, #4
    1e12:	0028      	movs	r0, r5
    1e14:	4b0b      	ldr	r3, [pc, #44]	; (1e44 <vTaskPriorityDisinheritAfterTimeout+0x84>)
    1e16:	4798      	blx	r3
						prvAddTaskToReadyList( pxTCB );
    1e18:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1e1a:	4a08      	ldr	r2, [pc, #32]	; (1e3c <vTaskPriorityDisinheritAfterTimeout+0x7c>)
    1e1c:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    1e1e:	4293      	cmp	r3, r2
    1e20:	d901      	bls.n	1e26 <vTaskPriorityDisinheritAfterTimeout+0x66>
    1e22:	4a06      	ldr	r2, [pc, #24]	; (1e3c <vTaskPriorityDisinheritAfterTimeout+0x7c>)
    1e24:	66d3      	str	r3, [r2, #108]	; 0x6c
    1e26:	0098      	lsls	r0, r3, #2
    1e28:	18c3      	adds	r3, r0, r3
    1e2a:	009b      	lsls	r3, r3, #2
    1e2c:	4804      	ldr	r0, [pc, #16]	; (1e40 <vTaskPriorityDisinheritAfterTimeout+0x80>)
    1e2e:	304c      	adds	r0, #76	; 0x4c
    1e30:	18c0      	adds	r0, r0, r3
    1e32:	0029      	movs	r1, r5
    1e34:	4b04      	ldr	r3, [pc, #16]	; (1e48 <vTaskPriorityDisinheritAfterTimeout+0x88>)
    1e36:	4798      	blx	r3
	}
    1e38:	e7d3      	b.n	1de2 <vTaskPriorityDisinheritAfterTimeout+0x22>
    1e3a:	46c0      	nop			; (mov r8, r8)
    1e3c:	2000438c 	.word	0x2000438c
    1e40:	2000430c 	.word	0x2000430c
    1e44:	00000383 	.word	0x00000383
    1e48:	0000033d 	.word	0x0000033d

00001e4c <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
    1e4c:	4b05      	ldr	r3, [pc, #20]	; (1e64 <pvTaskIncrementMutexHeldCount+0x18>)
    1e4e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1e50:	2b00      	cmp	r3, #0
    1e52:	d004      	beq.n	1e5e <pvTaskIncrementMutexHeldCount+0x12>
			( pxCurrentTCB->uxMutexesHeld )++;
    1e54:	4b03      	ldr	r3, [pc, #12]	; (1e64 <pvTaskIncrementMutexHeldCount+0x18>)
    1e56:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    1e58:	6c93      	ldr	r3, [r2, #72]	; 0x48
    1e5a:	3301      	adds	r3, #1
    1e5c:	6493      	str	r3, [r2, #72]	; 0x48
		return pxCurrentTCB;
    1e5e:	4b01      	ldr	r3, [pc, #4]	; (1e64 <pvTaskIncrementMutexHeldCount+0x18>)
    1e60:	6b58      	ldr	r0, [r3, #52]	; 0x34
	}
    1e62:	4770      	bx	lr
    1e64:	2000438c 	.word	0x2000438c

00001e68 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    1e68:	b510      	push	{r4, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    1e6a:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1e6c:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
    1e6e:	4291      	cmp	r1, r2
    1e70:	d80b      	bhi.n	1e8a <prvInsertTimerInActiveList+0x22>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e72:	1ad2      	subs	r2, r2, r3
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    1e74:	2401      	movs	r4, #1
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e76:	6983      	ldr	r3, [r0, #24]
    1e78:	429a      	cmp	r2, r3
    1e7a:	d211      	bcs.n	1ea0 <prvInsertTimerInActiveList+0x38>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    1e7c:	1d01      	adds	r1, r0, #4
    1e7e:	4b09      	ldr	r3, [pc, #36]	; (1ea4 <prvInsertTimerInActiveList+0x3c>)
    1e80:	6818      	ldr	r0, [r3, #0]
    1e82:	4b09      	ldr	r3, [pc, #36]	; (1ea8 <prvInsertTimerInActiveList+0x40>)
    1e84:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    1e86:	2400      	movs	r4, #0
    1e88:	e00a      	b.n	1ea0 <prvInsertTimerInActiveList+0x38>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1e8a:	429a      	cmp	r2, r3
    1e8c:	d202      	bcs.n	1e94 <prvInsertTimerInActiveList+0x2c>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    1e8e:	2401      	movs	r4, #1
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1e90:	4299      	cmp	r1, r3
    1e92:	d205      	bcs.n	1ea0 <prvInsertTimerInActiveList+0x38>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1e94:	1d01      	adds	r1, r0, #4
    1e96:	4b03      	ldr	r3, [pc, #12]	; (1ea4 <prvInsertTimerInActiveList+0x3c>)
    1e98:	6858      	ldr	r0, [r3, #4]
    1e9a:	4b03      	ldr	r3, [pc, #12]	; (1ea8 <prvInsertTimerInActiveList+0x40>)
    1e9c:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    1e9e:	2400      	movs	r4, #0
		}
	}

	return xProcessTimerNow;
}
    1ea0:	0020      	movs	r0, r4
    1ea2:	bd10      	pop	{r4, pc}
    1ea4:	20004410 	.word	0x20004410
    1ea8:	00000355 	.word	0x00000355

00001eac <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    1eac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    1eae:	4b10      	ldr	r3, [pc, #64]	; (1ef0 <prvCheckForValidListAndQueue+0x44>)
    1eb0:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
    1eb2:	4b10      	ldr	r3, [pc, #64]	; (1ef4 <prvCheckForValidListAndQueue+0x48>)
    1eb4:	689b      	ldr	r3, [r3, #8]
    1eb6:	2b00      	cmp	r3, #0
    1eb8:	d002      	beq.n	1ec0 <prvCheckForValidListAndQueue+0x14>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1eba:	4b0f      	ldr	r3, [pc, #60]	; (1ef8 <prvCheckForValidListAndQueue+0x4c>)
    1ebc:	4798      	blx	r3
}
    1ebe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise( &xActiveTimerList1 );
    1ec0:	4c0c      	ldr	r4, [pc, #48]	; (1ef4 <prvCheckForValidListAndQueue+0x48>)
    1ec2:	0026      	movs	r6, r4
    1ec4:	360c      	adds	r6, #12
    1ec6:	0030      	movs	r0, r6
    1ec8:	4f0c      	ldr	r7, [pc, #48]	; (1efc <prvCheckForValidListAndQueue+0x50>)
    1eca:	47b8      	blx	r7
			vListInitialise( &xActiveTimerList2 );
    1ecc:	0025      	movs	r5, r4
    1ece:	3520      	adds	r5, #32
    1ed0:	0028      	movs	r0, r5
    1ed2:	47b8      	blx	r7
			pxCurrentTimerList = &xActiveTimerList1;
    1ed4:	6066      	str	r6, [r4, #4]
			pxOverflowTimerList = &xActiveTimerList2;
    1ed6:	6025      	str	r5, [r4, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    1ed8:	2200      	movs	r2, #0
    1eda:	210c      	movs	r1, #12
    1edc:	2005      	movs	r0, #5
    1ede:	4b08      	ldr	r3, [pc, #32]	; (1f00 <prvCheckForValidListAndQueue+0x54>)
    1ee0:	4798      	blx	r3
    1ee2:	60a0      	str	r0, [r4, #8]
				if( xTimerQueue != NULL )
    1ee4:	2800      	cmp	r0, #0
    1ee6:	d0e8      	beq.n	1eba <prvCheckForValidListAndQueue+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    1ee8:	4906      	ldr	r1, [pc, #24]	; (1f04 <prvCheckForValidListAndQueue+0x58>)
    1eea:	4b07      	ldr	r3, [pc, #28]	; (1f08 <prvCheckForValidListAndQueue+0x5c>)
    1eec:	4798      	blx	r3
    1eee:	e7e4      	b.n	1eba <prvCheckForValidListAndQueue+0xe>
    1ef0:	000009f1 	.word	0x000009f1
    1ef4:	20004410 	.word	0x20004410
    1ef8:	00000a09 	.word	0x00000a09
    1efc:	00000321 	.word	0x00000321
    1f00:	00000d09 	.word	0x00000d09
    1f04:	00002600 	.word	0x00002600
    1f08:	0000129d 	.word	0x0000129d

00001f0c <xTimerCreateTimerTask>:
{
    1f0c:	b510      	push	{r4, lr}
    1f0e:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
    1f10:	4b0b      	ldr	r3, [pc, #44]	; (1f40 <xTimerCreateTimerTask+0x34>)
    1f12:	4798      	blx	r3
	if( xTimerQueue != NULL )
    1f14:	4b0b      	ldr	r3, [pc, #44]	; (1f44 <xTimerCreateTimerTask+0x38>)
    1f16:	689b      	ldr	r3, [r3, #8]
    1f18:	2b00      	cmp	r3, #0
    1f1a:	d00e      	beq.n	1f3a <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(	prvTimerTask,
    1f1c:	4b09      	ldr	r3, [pc, #36]	; (1f44 <xTimerCreateTimerTask+0x38>)
    1f1e:	3334      	adds	r3, #52	; 0x34
    1f20:	9301      	str	r3, [sp, #4]
    1f22:	2302      	movs	r3, #2
    1f24:	9300      	str	r3, [sp, #0]
    1f26:	2300      	movs	r3, #0
    1f28:	2250      	movs	r2, #80	; 0x50
    1f2a:	4907      	ldr	r1, [pc, #28]	; (1f48 <xTimerCreateTimerTask+0x3c>)
    1f2c:	4807      	ldr	r0, [pc, #28]	; (1f4c <xTimerCreateTimerTask+0x40>)
    1f2e:	4c08      	ldr	r4, [pc, #32]	; (1f50 <xTimerCreateTimerTask+0x44>)
    1f30:	47a0      	blx	r4
	configASSERT( xReturn );
    1f32:	2800      	cmp	r0, #0
    1f34:	d001      	beq.n	1f3a <xTimerCreateTimerTask+0x2e>
}
    1f36:	b002      	add	sp, #8
    1f38:	bd10      	pop	{r4, pc}
	configASSERT( xReturn );
    1f3a:	b672      	cpsid	i
    1f3c:	e7fe      	b.n	1f3c <xTimerCreateTimerTask+0x30>
    1f3e:	46c0      	nop			; (mov r8, r8)
    1f40:	00001ead 	.word	0x00001ead
    1f44:	20004410 	.word	0x20004410
    1f48:	00002608 	.word	0x00002608
    1f4c:	00002071 	.word	0x00002071
    1f50:	000015f5 	.word	0x000015f5

00001f54 <xTimerGenericCommand>:
{
    1f54:	b530      	push	{r4, r5, lr}
    1f56:	b085      	sub	sp, #20
    1f58:	0004      	movs	r4, r0
    1f5a:	001d      	movs	r5, r3
	configASSERT( xTimer );
    1f5c:	2800      	cmp	r0, #0
    1f5e:	d014      	beq.n	1f8a <xTimerGenericCommand+0x36>
	if( xTimerQueue != NULL )
    1f60:	4b13      	ldr	r3, [pc, #76]	; (1fb0 <xTimerGenericCommand+0x5c>)
    1f62:	6898      	ldr	r0, [r3, #8]
    1f64:	2800      	cmp	r0, #0
    1f66:	d021      	beq.n	1fac <xTimerGenericCommand+0x58>
		xMessage.xMessageID = xCommandID;
    1f68:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1f6a:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    1f6c:	9403      	str	r4, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1f6e:	2905      	cmp	r1, #5
    1f70:	dc15      	bgt.n	1f9e <xTimerGenericCommand+0x4a>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1f72:	4b10      	ldr	r3, [pc, #64]	; (1fb4 <xTimerGenericCommand+0x60>)
    1f74:	4798      	blx	r3
    1f76:	2802      	cmp	r0, #2
    1f78:	d009      	beq.n	1f8e <xTimerGenericCommand+0x3a>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1f7a:	4b0d      	ldr	r3, [pc, #52]	; (1fb0 <xTimerGenericCommand+0x5c>)
    1f7c:	6898      	ldr	r0, [r3, #8]
    1f7e:	2300      	movs	r3, #0
    1f80:	2200      	movs	r2, #0
    1f82:	a901      	add	r1, sp, #4
    1f84:	4c0c      	ldr	r4, [pc, #48]	; (1fb8 <xTimerGenericCommand+0x64>)
    1f86:	47a0      	blx	r4
    1f88:	e00e      	b.n	1fa8 <xTimerGenericCommand+0x54>
	configASSERT( xTimer );
    1f8a:	b672      	cpsid	i
    1f8c:	e7fe      	b.n	1f8c <xTimerGenericCommand+0x38>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1f8e:	4b08      	ldr	r3, [pc, #32]	; (1fb0 <xTimerGenericCommand+0x5c>)
    1f90:	6898      	ldr	r0, [r3, #8]
    1f92:	2300      	movs	r3, #0
    1f94:	9a08      	ldr	r2, [sp, #32]
    1f96:	a901      	add	r1, sp, #4
    1f98:	4c07      	ldr	r4, [pc, #28]	; (1fb8 <xTimerGenericCommand+0x64>)
    1f9a:	47a0      	blx	r4
    1f9c:	e004      	b.n	1fa8 <xTimerGenericCommand+0x54>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1f9e:	2300      	movs	r3, #0
    1fa0:	002a      	movs	r2, r5
    1fa2:	a901      	add	r1, sp, #4
    1fa4:	4c05      	ldr	r4, [pc, #20]	; (1fbc <xTimerGenericCommand+0x68>)
    1fa6:	47a0      	blx	r4
}
    1fa8:	b005      	add	sp, #20
    1faa:	bd30      	pop	{r4, r5, pc}
BaseType_t xReturn = pdFAIL;
    1fac:	2000      	movs	r0, #0
	return xReturn;
    1fae:	e7fb      	b.n	1fa8 <xTimerGenericCommand+0x54>
    1fb0:	20004410 	.word	0x20004410
    1fb4:	00001c91 	.word	0x00001c91
    1fb8:	00000d55 	.word	0x00000d55
    1fbc:	00000ee1 	.word	0x00000ee1

00001fc0 <prvSampleTimeNow>:
{
    1fc0:	b5f0      	push	{r4, r5, r6, r7, lr}
    1fc2:	46d6      	mov	lr, sl
    1fc4:	464f      	mov	r7, r9
    1fc6:	4646      	mov	r6, r8
    1fc8:	b5c0      	push	{r6, r7, lr}
    1fca:	b082      	sub	sp, #8
    1fcc:	4680      	mov	r8, r0
	xTimeNow = xTaskGetTickCount();
    1fce:	4b23      	ldr	r3, [pc, #140]	; (205c <STACK_SIZE+0x5c>)
    1fd0:	4798      	blx	r3
    1fd2:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
    1fd4:	4b22      	ldr	r3, [pc, #136]	; (2060 <STACK_SIZE+0x60>)
    1fd6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1fd8:	4298      	cmp	r0, r3
    1fda:	d317      	bcc.n	200c <STACK_SIZE+0xc>
		*pxTimerListsWereSwitched = pdFALSE;
    1fdc:	2300      	movs	r3, #0
    1fde:	4642      	mov	r2, r8
    1fe0:	6013      	str	r3, [r2, #0]
	xLastTime = xTimeNow;
    1fe2:	4b1f      	ldr	r3, [pc, #124]	; (2060 <STACK_SIZE+0x60>)
    1fe4:	4652      	mov	r2, sl
    1fe6:	639a      	str	r2, [r3, #56]	; 0x38
}
    1fe8:	4650      	mov	r0, sl
    1fea:	b002      	add	sp, #8
    1fec:	bc1c      	pop	{r2, r3, r4}
    1fee:	4690      	mov	r8, r2
    1ff0:	4699      	mov	r9, r3
    1ff2:	46a2      	mov	sl, r4
    1ff4:	bdf0      	pop	{r4, r5, r6, r7, pc}
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1ff6:	2300      	movs	r3, #0
    1ff8:	9300      	str	r3, [sp, #0]
    1ffa:	003a      	movs	r2, r7
    1ffc:	2100      	movs	r1, #0
    1ffe:	0020      	movs	r0, r4
    2000:	4c18      	ldr	r4, [pc, #96]	; (2064 <STACK_SIZE+0x64>)
    2002:	47a0      	blx	r4
				configASSERT( xResult );
    2004:	2800      	cmp	r0, #0
    2006:	d104      	bne.n	2012 <STACK_SIZE+0x12>
    2008:	b672      	cpsid	i
    200a:	e7fe      	b.n	200a <STACK_SIZE+0xa>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    200c:	4d14      	ldr	r5, [pc, #80]	; (2060 <STACK_SIZE+0x60>)
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    200e:	4b16      	ldr	r3, [pc, #88]	; (2068 <STACK_SIZE+0x68>)
    2010:	4699      	mov	r9, r3
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2012:	686b      	ldr	r3, [r5, #4]
    2014:	681a      	ldr	r2, [r3, #0]
    2016:	2a00      	cmp	r2, #0
    2018:	d017      	beq.n	204a <STACK_SIZE+0x4a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    201a:	68db      	ldr	r3, [r3, #12]
    201c:	681f      	ldr	r7, [r3, #0]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    201e:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2020:	1d26      	adds	r6, r4, #4
    2022:	0030      	movs	r0, r6
    2024:	47c8      	blx	r9
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2026:	0020      	movs	r0, r4
    2028:	6a63      	ldr	r3, [r4, #36]	; 0x24
    202a:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    202c:	69e3      	ldr	r3, [r4, #28]
    202e:	2b01      	cmp	r3, #1
    2030:	d1ef      	bne.n	2012 <STACK_SIZE+0x12>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2032:	69a3      	ldr	r3, [r4, #24]
    2034:	18fb      	adds	r3, r7, r3
			if( xReloadTime > xNextExpireTime )
    2036:	429f      	cmp	r7, r3
    2038:	d2dd      	bcs.n	1ff6 <prvSampleTimeNow+0x36>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    203a:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    203c:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    203e:	4b08      	ldr	r3, [pc, #32]	; (2060 <STACK_SIZE+0x60>)
    2040:	6858      	ldr	r0, [r3, #4]
    2042:	0031      	movs	r1, r6
    2044:	4b09      	ldr	r3, [pc, #36]	; (206c <STACK_SIZE+0x6c>)
    2046:	4798      	blx	r3
    2048:	e7e3      	b.n	2012 <STACK_SIZE+0x12>
	pxCurrentTimerList = pxOverflowTimerList;
    204a:	4a05      	ldr	r2, [pc, #20]	; (2060 <STACK_SIZE+0x60>)
    204c:	6811      	ldr	r1, [r2, #0]
    204e:	6051      	str	r1, [r2, #4]
	pxOverflowTimerList = pxTemp;
    2050:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
    2052:	2301      	movs	r3, #1
    2054:	4642      	mov	r2, r8
    2056:	6013      	str	r3, [r2, #0]
    2058:	e7c3      	b.n	1fe2 <prvSampleTimeNow+0x22>
    205a:	46c0      	nop			; (mov r8, r8)
    205c:	00001841 	.word	0x00001841
    2060:	20004410 	.word	0x20004410
    2064:	00001f55 	.word	0x00001f55
    2068:	00000383 	.word	0x00000383
    206c:	00000355 	.word	0x00000355

00002070 <prvTimerTask>:
{
    2070:	b5f0      	push	{r4, r5, r6, r7, lr}
    2072:	b089      	sub	sp, #36	; 0x24
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2074:	4f52      	ldr	r7, [pc, #328]	; (21c0 <prvTimerTask+0x150>)
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2076:	4b53      	ldr	r3, [pc, #332]	; (21c4 <prvTimerTask+0x154>)
    2078:	685b      	ldr	r3, [r3, #4]
    207a:	681a      	ldr	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
    207c:	2a00      	cmp	r2, #0
    207e:	d00e      	beq.n	209e <prvTimerTask+0x2e>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2080:	68db      	ldr	r3, [r3, #12]
    2082:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
    2084:	4b50      	ldr	r3, [pc, #320]	; (21c8 <prvTimerTask+0x158>)
    2086:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2088:	a805      	add	r0, sp, #20
    208a:	4b50      	ldr	r3, [pc, #320]	; (21cc <prvTimerTask+0x15c>)
    208c:	4798      	blx	r3
    208e:	0005      	movs	r5, r0
		if( xTimerListsWereSwitched == pdFALSE )
    2090:	9b05      	ldr	r3, [sp, #20]
    2092:	2b00      	cmp	r3, #0
    2094:	d15f      	bne.n	2156 <prvTimerTask+0xe6>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2096:	42a0      	cmp	r0, r4
    2098:	d236      	bcs.n	2108 <prvTimerTask+0x98>
    209a:	2200      	movs	r2, #0
    209c:	e00f      	b.n	20be <prvTimerTask+0x4e>
	vTaskSuspendAll();
    209e:	4b4a      	ldr	r3, [pc, #296]	; (21c8 <prvTimerTask+0x158>)
    20a0:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    20a2:	a805      	add	r0, sp, #20
    20a4:	4b49      	ldr	r3, [pc, #292]	; (21cc <prvTimerTask+0x15c>)
    20a6:	4798      	blx	r3
    20a8:	0005      	movs	r5, r0
		if( xTimerListsWereSwitched == pdFALSE )
    20aa:	9b05      	ldr	r3, [sp, #20]
    20ac:	2b00      	cmp	r3, #0
    20ae:	d152      	bne.n	2156 <prvTimerTask+0xe6>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    20b0:	4b44      	ldr	r3, [pc, #272]	; (21c4 <prvTimerTask+0x154>)
    20b2:	681b      	ldr	r3, [r3, #0]
    20b4:	681b      	ldr	r3, [r3, #0]
    20b6:	425a      	negs	r2, r3
    20b8:	415a      	adcs	r2, r3
    20ba:	b2d2      	uxtb	r2, r2
    20bc:	2400      	movs	r4, #0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    20be:	1b61      	subs	r1, r4, r5
    20c0:	4b40      	ldr	r3, [pc, #256]	; (21c4 <prvTimerTask+0x154>)
    20c2:	6898      	ldr	r0, [r3, #8]
    20c4:	4b42      	ldr	r3, [pc, #264]	; (21d0 <prvTimerTask+0x160>)
    20c6:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    20c8:	4b42      	ldr	r3, [pc, #264]	; (21d4 <prvTimerTask+0x164>)
    20ca:	4798      	blx	r3
    20cc:	2800      	cmp	r0, #0
    20ce:	d03f      	beq.n	2150 <prvTimerTask+0xe0>
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    20d0:	4d3c      	ldr	r5, [pc, #240]	; (21c4 <prvTimerTask+0x154>)
    20d2:	4c41      	ldr	r4, [pc, #260]	; (21d8 <prvTimerTask+0x168>)
    20d4:	2200      	movs	r2, #0
    20d6:	a905      	add	r1, sp, #20
    20d8:	68a8      	ldr	r0, [r5, #8]
    20da:	47a0      	blx	r4
    20dc:	2800      	cmp	r0, #0
    20de:	d0ca      	beq.n	2076 <prvTimerTask+0x6>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    20e0:	9b05      	ldr	r3, [sp, #20]
    20e2:	9303      	str	r3, [sp, #12]
    20e4:	2b00      	cmp	r3, #0
    20e6:	dbf5      	blt.n	20d4 <prvTimerTask+0x64>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    20e8:	9e07      	ldr	r6, [sp, #28]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    20ea:	6973      	ldr	r3, [r6, #20]
    20ec:	2b00      	cmp	r3, #0
    20ee:	d001      	beq.n	20f4 <prvTimerTask+0x84>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    20f0:	1d30      	adds	r0, r6, #4
    20f2:	47b8      	blx	r7
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    20f4:	a804      	add	r0, sp, #16
    20f6:	4b35      	ldr	r3, [pc, #212]	; (21cc <prvTimerTask+0x15c>)
    20f8:	4798      	blx	r3
			switch( xMessage.xMessageID )
    20fa:	9b05      	ldr	r3, [sp, #20]
    20fc:	2b09      	cmp	r3, #9
    20fe:	d8e9      	bhi.n	20d4 <prvTimerTask+0x64>
    2100:	009b      	lsls	r3, r3, #2
    2102:	4a36      	ldr	r2, [pc, #216]	; (21dc <prvTimerTask+0x16c>)
    2104:	58d3      	ldr	r3, [r2, r3]
    2106:	469f      	mov	pc, r3
				( void ) xTaskResumeAll();
    2108:	4b32      	ldr	r3, [pc, #200]	; (21d4 <prvTimerTask+0x164>)
    210a:	4798      	blx	r3
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    210c:	4b2d      	ldr	r3, [pc, #180]	; (21c4 <prvTimerTask+0x154>)
    210e:	685b      	ldr	r3, [r3, #4]
    2110:	68db      	ldr	r3, [r3, #12]
    2112:	68de      	ldr	r6, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2114:	1d30      	adds	r0, r6, #4
    2116:	4b2a      	ldr	r3, [pc, #168]	; (21c0 <prvTimerTask+0x150>)
    2118:	4798      	blx	r3
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    211a:	69f3      	ldr	r3, [r6, #28]
    211c:	2b01      	cmp	r3, #1
    211e:	d003      	beq.n	2128 <prvTimerTask+0xb8>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2120:	6a73      	ldr	r3, [r6, #36]	; 0x24
    2122:	0030      	movs	r0, r6
    2124:	4798      	blx	r3
    2126:	e7d3      	b.n	20d0 <prvTimerTask+0x60>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2128:	69b3      	ldr	r3, [r6, #24]
    212a:	18e1      	adds	r1, r4, r3
    212c:	0023      	movs	r3, r4
    212e:	002a      	movs	r2, r5
    2130:	0030      	movs	r0, r6
    2132:	4d2b      	ldr	r5, [pc, #172]	; (21e0 <prvTimerTask+0x170>)
    2134:	47a8      	blx	r5
    2136:	2800      	cmp	r0, #0
    2138:	d0f2      	beq.n	2120 <prvTimerTask+0xb0>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    213a:	2300      	movs	r3, #0
    213c:	9300      	str	r3, [sp, #0]
    213e:	0022      	movs	r2, r4
    2140:	2100      	movs	r1, #0
    2142:	0030      	movs	r0, r6
    2144:	4c27      	ldr	r4, [pc, #156]	; (21e4 <prvTimerTask+0x174>)
    2146:	47a0      	blx	r4
			configASSERT( xResult );
    2148:	2800      	cmp	r0, #0
    214a:	d1e9      	bne.n	2120 <prvTimerTask+0xb0>
    214c:	b672      	cpsid	i
    214e:	e7fe      	b.n	214e <prvTimerTask+0xde>
					portYIELD_WITHIN_API();
    2150:	4b25      	ldr	r3, [pc, #148]	; (21e8 <prvTimerTask+0x178>)
    2152:	4798      	blx	r3
    2154:	e7bc      	b.n	20d0 <prvTimerTask+0x60>
			( void ) xTaskResumeAll();
    2156:	4b1f      	ldr	r3, [pc, #124]	; (21d4 <prvTimerTask+0x164>)
    2158:	4798      	blx	r3
    215a:	e7b9      	b.n	20d0 <prvTimerTask+0x60>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    215c:	9b06      	ldr	r3, [sp, #24]
    215e:	69b2      	ldr	r2, [r6, #24]
    2160:	4694      	mov	ip, r2
    2162:	4463      	add	r3, ip
    2164:	0019      	movs	r1, r3
    2166:	9b06      	ldr	r3, [sp, #24]
    2168:	0002      	movs	r2, r0
    216a:	0030      	movs	r0, r6
    216c:	4c1c      	ldr	r4, [pc, #112]	; (21e0 <prvTimerTask+0x170>)
    216e:	47a0      	blx	r4
    2170:	2800      	cmp	r0, #0
    2172:	d0ae      	beq.n	20d2 <prvTimerTask+0x62>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2174:	0030      	movs	r0, r6
    2176:	6a73      	ldr	r3, [r6, #36]	; 0x24
    2178:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    217a:	69f3      	ldr	r3, [r6, #28]
    217c:	2b01      	cmp	r3, #1
    217e:	d1a8      	bne.n	20d2 <prvTimerTask+0x62>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2180:	9b06      	ldr	r3, [sp, #24]
    2182:	69b1      	ldr	r1, [r6, #24]
    2184:	468c      	mov	ip, r1
    2186:	4463      	add	r3, ip
    2188:	001a      	movs	r2, r3
    218a:	2300      	movs	r3, #0
    218c:	9300      	str	r3, [sp, #0]
    218e:	2100      	movs	r1, #0
    2190:	0030      	movs	r0, r6
    2192:	4c14      	ldr	r4, [pc, #80]	; (21e4 <prvTimerTask+0x174>)
    2194:	47a0      	blx	r4
							configASSERT( xResult );
    2196:	2800      	cmp	r0, #0
    2198:	d19b      	bne.n	20d2 <prvTimerTask+0x62>
    219a:	b672      	cpsid	i
    219c:	e7fe      	b.n	219c <prvTimerTask+0x12c>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    219e:	9906      	ldr	r1, [sp, #24]
    21a0:	61b1      	str	r1, [r6, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    21a2:	2900      	cmp	r1, #0
    21a4:	d006      	beq.n	21b4 <prvTimerTask+0x144>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    21a6:	1841      	adds	r1, r0, r1
    21a8:	0003      	movs	r3, r0
    21aa:	0002      	movs	r2, r0
    21ac:	0030      	movs	r0, r6
    21ae:	4c0c      	ldr	r4, [pc, #48]	; (21e0 <prvTimerTask+0x170>)
    21b0:	47a0      	blx	r4
    21b2:	e78e      	b.n	20d2 <prvTimerTask+0x62>
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    21b4:	b672      	cpsid	i
    21b6:	e7fe      	b.n	21b6 <prvTimerTask+0x146>
						vPortFree( pxTimer );
    21b8:	0030      	movs	r0, r6
    21ba:	4b0c      	ldr	r3, [pc, #48]	; (21ec <prvTimerTask+0x17c>)
    21bc:	4798      	blx	r3
    21be:	e788      	b.n	20d2 <prvTimerTask+0x62>
    21c0:	00000383 	.word	0x00000383
    21c4:	20004410 	.word	0x20004410
    21c8:	00001831 	.word	0x00001831
    21cc:	00001fc1 	.word	0x00001fc1
    21d0:	000012cd 	.word	0x000012cd
    21d4:	0000195d 	.word	0x0000195d
    21d8:	00000fb1 	.word	0x00000fb1
    21dc:	000025d8 	.word	0x000025d8
    21e0:	00001e69 	.word	0x00001e69
    21e4:	00001f55 	.word	0x00001f55
    21e8:	000009d9 	.word	0x000009d9
    21ec:	000002d9 	.word	0x000002d9

000021f0 <initUART>:
/* Replace with your library code */
void initUART(void) {

	/* APBCMASK */
   /* SERCOM 0 enable*/
	PM->APBCMASK.reg |= PM_APBCMASK_SERCOM0;
    21f0:	4a1f      	ldr	r2, [pc, #124]	; (2270 <initUART+0x80>)
    21f2:	6a13      	ldr	r3, [r2, #32]
    21f4:	2104      	movs	r1, #4
    21f6:	430b      	orrs	r3, r1
    21f8:	6213      	str	r3, [r2, #32]

	/*GCLK configuration for sercom0 module: using generic clock generator 0, ID for sercom0, enable GCLK*/
    GCLK->GENCTRL.reg=GCLK_GENCTRL_SRC_OSC8M|GCLK_GENCTRL_ID(0)|
    21fa:	4b1e      	ldr	r3, [pc, #120]	; (2274 <initUART+0x84>)
    21fc:	2283      	movs	r2, #131	; 0x83
    21fe:	0252      	lsls	r2, r2, #9
    2200:	605a      	str	r2, [r3, #4]
	GCLK_GENCTRL_GENEN;

	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM0_GCLK_ID_CORE) |
    2202:	4a1d      	ldr	r2, [pc, #116]	; (2278 <initUART+0x88>)
    2204:	805a      	strh	r2, [r3, #2]
	GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN(0);

  /*CONFIGURAR PA10 y PA11 como salidas tipo C (SERCOM 0) */
  PORT->Group[0].PINCFG[PIN_PA10].reg= PA10_TX;
    2206:	4b1d      	ldr	r3, [pc, #116]	; (227c <initUART+0x8c>)
    2208:	3903      	subs	r1, #3
    220a:	224a      	movs	r2, #74	; 0x4a
    220c:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PINCFG[PIN_PA11].reg= PA11_RX;
    220e:	3106      	adds	r1, #6
    2210:	3201      	adds	r2, #1
    2212:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PMUX[5].bit.PMUXE=Type_C;
    2214:	312e      	adds	r1, #46	; 0x2e
    2216:	5c5a      	ldrb	r2, [r3, r1]
    2218:	200f      	movs	r0, #15
    221a:	4382      	bics	r2, r0
    221c:	2002      	movs	r0, #2
    221e:	4302      	orrs	r2, r0
    2220:	545a      	strb	r2, [r3, r1]
  PORT->Group[0].PMUX[5].bit.PMUXO=Type_C;
    2222:	5c58      	ldrb	r0, [r3, r1]
    2224:	220f      	movs	r2, #15
    2226:	4002      	ands	r2, r0
    2228:	2020      	movs	r0, #32
    222a:	4302      	orrs	r2, r0
    222c:	545a      	strb	r2, [r3, r1]
	
	//desahibilitar UART para inicializacion
	SERCOM0->USART.CTRLA.bit.ENABLE=0;
    222e:	4b14      	ldr	r3, [pc, #80]	; (2280 <initUART+0x90>)
    2230:	681a      	ldr	r2, [r3, #0]
    2232:	3933      	subs	r1, #51	; 0x33
    2234:	438a      	bics	r2, r1
    2236:	601a      	str	r2, [r3, #0]
   
   DEFINES:
   1)SERCOM_USART_CTRLA_DORD (_U(0x1) << SERCOM_USART_CTRLA_DORD_Pos)
   2)SERCOM_USART_CTRLA_MODE_USART_INT_CLK (0x1 << 2)
   3)SERCOM_USART_CTRLA_RXPO(value) (SERCOM_USART_CTRLA_RXPO_Msk & ((value) << SERCOM_USART_CTRLA_RXPO_Pos) */
	SERCOM0->USART.CTRLA.reg =
    2238:	4a12      	ldr	r2, [pc, #72]	; (2284 <initUART+0x94>)
    223a:	601a      	str	r2, [r3, #0]
	SERCOM_USART_CTRLA_DORD | SERCOM_USART_CTRLA_MODE_USART_INT_CLK |
	SERCOM_USART_CTRLA_RXPO(3) | SERCOM_USART_CTRLA_TXPO(1);
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    223c:	001a      	movs	r2, r3
    223e:	69d3      	ldr	r3, [r2, #28]
    2240:	2b00      	cmp	r3, #0
    2242:	d1fc      	bne.n	223e <initUART+0x4e>
	uint64_t br = (uint64_t)65536 * (8000000 - 16 * 9600) / 8000000;

	SERCOM0->USART.BAUD.reg = (uint16_t)br;
    2244:	4a10      	ldr	r2, [pc, #64]	; (2288 <initUART+0x98>)
    2246:	4b0e      	ldr	r3, [pc, #56]	; (2280 <initUART+0x90>)
    2248:	819a      	strh	r2, [r3, #12]
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    224a:	001a      	movs	r2, r3
    224c:	69d3      	ldr	r3, [r2, #28]
    224e:	2b00      	cmp	r3, #0
    2250:	d1fc      	bne.n	224c <initUART+0x5c>
	SERCOM0->USART.CTRLB.reg = SERCOM_USART_CTRLB_RXEN | SERCOM_USART_CTRLB_TXEN | SERCOM_USART_CTRLB_CHSIZE(0/*8 bits*/);
    2252:	22c0      	movs	r2, #192	; 0xc0
    2254:	0292      	lsls	r2, r2, #10
    2256:	4b0a      	ldr	r3, [pc, #40]	; (2280 <initUART+0x90>)
    2258:	605a      	str	r2, [r3, #4]
    while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    225a:	001a      	movs	r2, r3
    225c:	69d3      	ldr	r3, [r2, #28]
    225e:	2b00      	cmp	r3, #0
    2260:	d1fc      	bne.n	225c <initUART+0x6c>
	SERCOM0->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    2262:	4a07      	ldr	r2, [pc, #28]	; (2280 <initUART+0x90>)
    2264:	6813      	ldr	r3, [r2, #0]
    2266:	2102      	movs	r1, #2
    2268:	430b      	orrs	r3, r1
    226a:	6013      	str	r3, [r2, #0]
}
    226c:	4770      	bx	lr
    226e:	46c0      	nop			; (mov r8, r8)
    2270:	40000400 	.word	0x40000400
    2274:	40000c00 	.word	0x40000c00
    2278:	00004014 	.word	0x00004014
    227c:	41004400 	.word	0x41004400
    2280:	42000800 	.word	0x42000800
    2284:	40310004 	.word	0x40310004
    2288:	fffffb15 	.word	0xfffffb15

0000228c <__libc_init_array>:
    228c:	b570      	push	{r4, r5, r6, lr}
    228e:	4e0d      	ldr	r6, [pc, #52]	; (22c4 <__libc_init_array+0x38>)
    2290:	4d0d      	ldr	r5, [pc, #52]	; (22c8 <__libc_init_array+0x3c>)
    2292:	2400      	movs	r4, #0
    2294:	1bad      	subs	r5, r5, r6
    2296:	10ad      	asrs	r5, r5, #2
    2298:	d005      	beq.n	22a6 <__libc_init_array+0x1a>
    229a:	00a3      	lsls	r3, r4, #2
    229c:	58f3      	ldr	r3, [r6, r3]
    229e:	3401      	adds	r4, #1
    22a0:	4798      	blx	r3
    22a2:	42a5      	cmp	r5, r4
    22a4:	d1f9      	bne.n	229a <__libc_init_array+0xe>
    22a6:	f000 f9b5 	bl	2614 <_init>
    22aa:	4e08      	ldr	r6, [pc, #32]	; (22cc <__libc_init_array+0x40>)
    22ac:	4d08      	ldr	r5, [pc, #32]	; (22d0 <__libc_init_array+0x44>)
    22ae:	2400      	movs	r4, #0
    22b0:	1bad      	subs	r5, r5, r6
    22b2:	10ad      	asrs	r5, r5, #2
    22b4:	d005      	beq.n	22c2 <__libc_init_array+0x36>
    22b6:	00a3      	lsls	r3, r4, #2
    22b8:	58f3      	ldr	r3, [r6, r3]
    22ba:	3401      	adds	r4, #1
    22bc:	4798      	blx	r3
    22be:	42a5      	cmp	r5, r4
    22c0:	d1f9      	bne.n	22b6 <__libc_init_array+0x2a>
    22c2:	bd70      	pop	{r4, r5, r6, pc}
    22c4:	00002620 	.word	0x00002620
    22c8:	00002620 	.word	0x00002620
    22cc:	00002620 	.word	0x00002620
    22d0:	00002628 	.word	0x00002628

000022d4 <memcpy>:
    22d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    22d6:	0005      	movs	r5, r0
    22d8:	2a0f      	cmp	r2, #15
    22da:	d92f      	bls.n	233c <memcpy+0x68>
    22dc:	000b      	movs	r3, r1
    22de:	4303      	orrs	r3, r0
    22e0:	079b      	lsls	r3, r3, #30
    22e2:	d134      	bne.n	234e <memcpy+0x7a>
    22e4:	0016      	movs	r6, r2
    22e6:	000c      	movs	r4, r1
    22e8:	0003      	movs	r3, r0
    22ea:	3e10      	subs	r6, #16
    22ec:	0935      	lsrs	r5, r6, #4
    22ee:	3501      	adds	r5, #1
    22f0:	012d      	lsls	r5, r5, #4
    22f2:	1945      	adds	r5, r0, r5
    22f4:	6827      	ldr	r7, [r4, #0]
    22f6:	601f      	str	r7, [r3, #0]
    22f8:	6867      	ldr	r7, [r4, #4]
    22fa:	605f      	str	r7, [r3, #4]
    22fc:	68a7      	ldr	r7, [r4, #8]
    22fe:	609f      	str	r7, [r3, #8]
    2300:	68e7      	ldr	r7, [r4, #12]
    2302:	3410      	adds	r4, #16
    2304:	60df      	str	r7, [r3, #12]
    2306:	3310      	adds	r3, #16
    2308:	429d      	cmp	r5, r3
    230a:	d1f3      	bne.n	22f4 <memcpy+0x20>
    230c:	230f      	movs	r3, #15
    230e:	439e      	bics	r6, r3
    2310:	3610      	adds	r6, #16
    2312:	1985      	adds	r5, r0, r6
    2314:	1989      	adds	r1, r1, r6
    2316:	4013      	ands	r3, r2
    2318:	2b03      	cmp	r3, #3
    231a:	d91a      	bls.n	2352 <memcpy+0x7e>
    231c:	1f1e      	subs	r6, r3, #4
    231e:	2300      	movs	r3, #0
    2320:	08b4      	lsrs	r4, r6, #2
    2322:	3401      	adds	r4, #1
    2324:	00a4      	lsls	r4, r4, #2
    2326:	58cf      	ldr	r7, [r1, r3]
    2328:	50ef      	str	r7, [r5, r3]
    232a:	3304      	adds	r3, #4
    232c:	42a3      	cmp	r3, r4
    232e:	d1fa      	bne.n	2326 <memcpy+0x52>
    2330:	2403      	movs	r4, #3
    2332:	43a6      	bics	r6, r4
    2334:	1d33      	adds	r3, r6, #4
    2336:	4022      	ands	r2, r4
    2338:	18c9      	adds	r1, r1, r3
    233a:	18ed      	adds	r5, r5, r3
    233c:	2a00      	cmp	r2, #0
    233e:	d005      	beq.n	234c <memcpy+0x78>
    2340:	2300      	movs	r3, #0
    2342:	5ccc      	ldrb	r4, [r1, r3]
    2344:	54ec      	strb	r4, [r5, r3]
    2346:	3301      	adds	r3, #1
    2348:	4293      	cmp	r3, r2
    234a:	d1fa      	bne.n	2342 <memcpy+0x6e>
    234c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    234e:	0005      	movs	r5, r0
    2350:	e7f6      	b.n	2340 <memcpy+0x6c>
    2352:	001a      	movs	r2, r3
    2354:	e7f2      	b.n	233c <memcpy+0x68>
    2356:	46c0      	nop			; (mov r8, r8)

00002358 <memset>:
    2358:	b5f0      	push	{r4, r5, r6, r7, lr}
    235a:	0783      	lsls	r3, r0, #30
    235c:	d043      	beq.n	23e6 <memset+0x8e>
    235e:	1e54      	subs	r4, r2, #1
    2360:	2a00      	cmp	r2, #0
    2362:	d03f      	beq.n	23e4 <memset+0x8c>
    2364:	b2ce      	uxtb	r6, r1
    2366:	0002      	movs	r2, r0
    2368:	2503      	movs	r5, #3
    236a:	e002      	b.n	2372 <memset+0x1a>
    236c:	001a      	movs	r2, r3
    236e:	3c01      	subs	r4, #1
    2370:	d338      	bcc.n	23e4 <memset+0x8c>
    2372:	1c53      	adds	r3, r2, #1
    2374:	7016      	strb	r6, [r2, #0]
    2376:	422b      	tst	r3, r5
    2378:	d1f8      	bne.n	236c <memset+0x14>
    237a:	2c03      	cmp	r4, #3
    237c:	d92a      	bls.n	23d4 <memset+0x7c>
    237e:	22ff      	movs	r2, #255	; 0xff
    2380:	400a      	ands	r2, r1
    2382:	0215      	lsls	r5, r2, #8
    2384:	4315      	orrs	r5, r2
    2386:	042a      	lsls	r2, r5, #16
    2388:	4315      	orrs	r5, r2
    238a:	2c0f      	cmp	r4, #15
    238c:	d914      	bls.n	23b8 <memset+0x60>
    238e:	0027      	movs	r7, r4
    2390:	001a      	movs	r2, r3
    2392:	3f10      	subs	r7, #16
    2394:	093e      	lsrs	r6, r7, #4
    2396:	3601      	adds	r6, #1
    2398:	0136      	lsls	r6, r6, #4
    239a:	199e      	adds	r6, r3, r6
    239c:	6015      	str	r5, [r2, #0]
    239e:	6055      	str	r5, [r2, #4]
    23a0:	6095      	str	r5, [r2, #8]
    23a2:	60d5      	str	r5, [r2, #12]
    23a4:	3210      	adds	r2, #16
    23a6:	4296      	cmp	r6, r2
    23a8:	d1f8      	bne.n	239c <memset+0x44>
    23aa:	220f      	movs	r2, #15
    23ac:	4397      	bics	r7, r2
    23ae:	3710      	adds	r7, #16
    23b0:	19db      	adds	r3, r3, r7
    23b2:	4014      	ands	r4, r2
    23b4:	2c03      	cmp	r4, #3
    23b6:	d90d      	bls.n	23d4 <memset+0x7c>
    23b8:	001a      	movs	r2, r3
    23ba:	1f27      	subs	r7, r4, #4
    23bc:	08be      	lsrs	r6, r7, #2
    23be:	3601      	adds	r6, #1
    23c0:	00b6      	lsls	r6, r6, #2
    23c2:	199e      	adds	r6, r3, r6
    23c4:	c220      	stmia	r2!, {r5}
    23c6:	42b2      	cmp	r2, r6
    23c8:	d1fc      	bne.n	23c4 <memset+0x6c>
    23ca:	2203      	movs	r2, #3
    23cc:	4397      	bics	r7, r2
    23ce:	3704      	adds	r7, #4
    23d0:	19db      	adds	r3, r3, r7
    23d2:	4014      	ands	r4, r2
    23d4:	2c00      	cmp	r4, #0
    23d6:	d005      	beq.n	23e4 <memset+0x8c>
    23d8:	b2c9      	uxtb	r1, r1
    23da:	191c      	adds	r4, r3, r4
    23dc:	7019      	strb	r1, [r3, #0]
    23de:	3301      	adds	r3, #1
    23e0:	429c      	cmp	r4, r3
    23e2:	d1fb      	bne.n	23dc <memset+0x84>
    23e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    23e6:	0014      	movs	r4, r2
    23e8:	0003      	movs	r3, r0
    23ea:	e7c6      	b.n	237a <memset+0x22>

000023ec <register_fini>:
    23ec:	4b03      	ldr	r3, [pc, #12]	; (23fc <register_fini+0x10>)
    23ee:	b510      	push	{r4, lr}
    23f0:	2b00      	cmp	r3, #0
    23f2:	d002      	beq.n	23fa <register_fini+0xe>
    23f4:	4802      	ldr	r0, [pc, #8]	; (2400 <register_fini+0x14>)
    23f6:	f000 f805 	bl	2404 <atexit>
    23fa:	bd10      	pop	{r4, pc}
    23fc:	00000000 	.word	0x00000000
    2400:	00002415 	.word	0x00002415

00002404 <atexit>:
    2404:	b510      	push	{r4, lr}
    2406:	0001      	movs	r1, r0
    2408:	2300      	movs	r3, #0
    240a:	2200      	movs	r2, #0
    240c:	2000      	movs	r0, #0
    240e:	f000 f81f 	bl	2450 <__register_exitproc>
    2412:	bd10      	pop	{r4, pc}

00002414 <__libc_fini_array>:
    2414:	b570      	push	{r4, r5, r6, lr}
    2416:	4b09      	ldr	r3, [pc, #36]	; (243c <__libc_fini_array+0x28>)
    2418:	4c09      	ldr	r4, [pc, #36]	; (2440 <__libc_fini_array+0x2c>)
    241a:	1ae4      	subs	r4, r4, r3
    241c:	10a4      	asrs	r4, r4, #2
    241e:	d009      	beq.n	2434 <__libc_fini_array+0x20>
    2420:	4a08      	ldr	r2, [pc, #32]	; (2444 <__libc_fini_array+0x30>)
    2422:	18a5      	adds	r5, r4, r2
    2424:	00ad      	lsls	r5, r5, #2
    2426:	18ed      	adds	r5, r5, r3
    2428:	682b      	ldr	r3, [r5, #0]
    242a:	3c01      	subs	r4, #1
    242c:	4798      	blx	r3
    242e:	3d04      	subs	r5, #4
    2430:	2c00      	cmp	r4, #0
    2432:	d1f9      	bne.n	2428 <__libc_fini_array+0x14>
    2434:	f000 f8f8 	bl	2628 <_fini>
    2438:	bd70      	pop	{r4, r5, r6, pc}
    243a:	46c0      	nop			; (mov r8, r8)
    243c:	00002634 	.word	0x00002634
    2440:	00002638 	.word	0x00002638
    2444:	3fffffff 	.word	0x3fffffff

00002448 <__retarget_lock_acquire_recursive>:
    2448:	4770      	bx	lr
    244a:	46c0      	nop			; (mov r8, r8)

0000244c <__retarget_lock_release_recursive>:
    244c:	4770      	bx	lr
    244e:	46c0      	nop			; (mov r8, r8)

00002450 <__register_exitproc>:
    2450:	b5f0      	push	{r4, r5, r6, r7, lr}
    2452:	464e      	mov	r6, r9
    2454:	4645      	mov	r5, r8
    2456:	46de      	mov	lr, fp
    2458:	4657      	mov	r7, sl
    245a:	b5e0      	push	{r5, r6, r7, lr}
    245c:	4d36      	ldr	r5, [pc, #216]	; (2538 <__register_exitproc+0xe8>)
    245e:	b083      	sub	sp, #12
    2460:	0006      	movs	r6, r0
    2462:	6828      	ldr	r0, [r5, #0]
    2464:	4698      	mov	r8, r3
    2466:	000f      	movs	r7, r1
    2468:	4691      	mov	r9, r2
    246a:	f7ff ffed 	bl	2448 <__retarget_lock_acquire_recursive>
    246e:	4b33      	ldr	r3, [pc, #204]	; (253c <__register_exitproc+0xec>)
    2470:	681c      	ldr	r4, [r3, #0]
    2472:	23a4      	movs	r3, #164	; 0xa4
    2474:	005b      	lsls	r3, r3, #1
    2476:	58e0      	ldr	r0, [r4, r3]
    2478:	2800      	cmp	r0, #0
    247a:	d052      	beq.n	2522 <__register_exitproc+0xd2>
    247c:	6843      	ldr	r3, [r0, #4]
    247e:	2b1f      	cmp	r3, #31
    2480:	dc13      	bgt.n	24aa <__register_exitproc+0x5a>
    2482:	1c5a      	adds	r2, r3, #1
    2484:	9201      	str	r2, [sp, #4]
    2486:	2e00      	cmp	r6, #0
    2488:	d128      	bne.n	24dc <__register_exitproc+0x8c>
    248a:	9a01      	ldr	r2, [sp, #4]
    248c:	3302      	adds	r3, #2
    248e:	009b      	lsls	r3, r3, #2
    2490:	6042      	str	r2, [r0, #4]
    2492:	501f      	str	r7, [r3, r0]
    2494:	6828      	ldr	r0, [r5, #0]
    2496:	f7ff ffd9 	bl	244c <__retarget_lock_release_recursive>
    249a:	2000      	movs	r0, #0
    249c:	b003      	add	sp, #12
    249e:	bc3c      	pop	{r2, r3, r4, r5}
    24a0:	4690      	mov	r8, r2
    24a2:	4699      	mov	r9, r3
    24a4:	46a2      	mov	sl, r4
    24a6:	46ab      	mov	fp, r5
    24a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    24aa:	4b25      	ldr	r3, [pc, #148]	; (2540 <__register_exitproc+0xf0>)
    24ac:	2b00      	cmp	r3, #0
    24ae:	d03d      	beq.n	252c <__register_exitproc+0xdc>
    24b0:	20c8      	movs	r0, #200	; 0xc8
    24b2:	0040      	lsls	r0, r0, #1
    24b4:	e000      	b.n	24b8 <__register_exitproc+0x68>
    24b6:	bf00      	nop
    24b8:	2800      	cmp	r0, #0
    24ba:	d037      	beq.n	252c <__register_exitproc+0xdc>
    24bc:	22a4      	movs	r2, #164	; 0xa4
    24be:	2300      	movs	r3, #0
    24c0:	0052      	lsls	r2, r2, #1
    24c2:	58a1      	ldr	r1, [r4, r2]
    24c4:	6043      	str	r3, [r0, #4]
    24c6:	6001      	str	r1, [r0, #0]
    24c8:	50a0      	str	r0, [r4, r2]
    24ca:	3240      	adds	r2, #64	; 0x40
    24cc:	5083      	str	r3, [r0, r2]
    24ce:	3204      	adds	r2, #4
    24d0:	5083      	str	r3, [r0, r2]
    24d2:	3301      	adds	r3, #1
    24d4:	9301      	str	r3, [sp, #4]
    24d6:	2300      	movs	r3, #0
    24d8:	2e00      	cmp	r6, #0
    24da:	d0d6      	beq.n	248a <__register_exitproc+0x3a>
    24dc:	009a      	lsls	r2, r3, #2
    24de:	4692      	mov	sl, r2
    24e0:	4482      	add	sl, r0
    24e2:	464a      	mov	r2, r9
    24e4:	2188      	movs	r1, #136	; 0x88
    24e6:	4654      	mov	r4, sl
    24e8:	5062      	str	r2, [r4, r1]
    24ea:	22c4      	movs	r2, #196	; 0xc4
    24ec:	0052      	lsls	r2, r2, #1
    24ee:	4691      	mov	r9, r2
    24f0:	4481      	add	r9, r0
    24f2:	464a      	mov	r2, r9
    24f4:	3987      	subs	r1, #135	; 0x87
    24f6:	4099      	lsls	r1, r3
    24f8:	6812      	ldr	r2, [r2, #0]
    24fa:	468b      	mov	fp, r1
    24fc:	430a      	orrs	r2, r1
    24fe:	4694      	mov	ip, r2
    2500:	464a      	mov	r2, r9
    2502:	4661      	mov	r1, ip
    2504:	6011      	str	r1, [r2, #0]
    2506:	2284      	movs	r2, #132	; 0x84
    2508:	4641      	mov	r1, r8
    250a:	0052      	lsls	r2, r2, #1
    250c:	50a1      	str	r1, [r4, r2]
    250e:	2e02      	cmp	r6, #2
    2510:	d1bb      	bne.n	248a <__register_exitproc+0x3a>
    2512:	0002      	movs	r2, r0
    2514:	465c      	mov	r4, fp
    2516:	328d      	adds	r2, #141	; 0x8d
    2518:	32ff      	adds	r2, #255	; 0xff
    251a:	6811      	ldr	r1, [r2, #0]
    251c:	430c      	orrs	r4, r1
    251e:	6014      	str	r4, [r2, #0]
    2520:	e7b3      	b.n	248a <__register_exitproc+0x3a>
    2522:	0020      	movs	r0, r4
    2524:	304d      	adds	r0, #77	; 0x4d
    2526:	30ff      	adds	r0, #255	; 0xff
    2528:	50e0      	str	r0, [r4, r3]
    252a:	e7a7      	b.n	247c <__register_exitproc+0x2c>
    252c:	6828      	ldr	r0, [r5, #0]
    252e:	f7ff ff8d 	bl	244c <__retarget_lock_release_recursive>
    2532:	2001      	movs	r0, #1
    2534:	4240      	negs	r0, r0
    2536:	e7b1      	b.n	249c <__register_exitproc+0x4c>
    2538:	20000438 	.word	0x20000438
    253c:	00002610 	.word	0x00002610
    2540:	00000000 	.word	0x00000000
    2544:	00000058 	.word	0x00000058
    2548:	54524155 	.word	0x54524155
    254c:	6e6f4320 	.word	0x6e6f4320
    2550:	7463656e 	.word	0x7463656e
    2554:	206e6f69 	.word	0x206e6f69
    2558:	6f727245 	.word	0x6f727245
    255c:	00000072 	.word	0x00000072
    2560:	736f6c63 	.word	0x736f6c63
    2564:	6f642065 	.word	0x6f642065
    2568:	0000726f 	.word	0x0000726f
    256c:	6e65706f 	.word	0x6e65706f
    2570:	6f6f6420 	.word	0x6f6f6420
    2574:	00000072 	.word	0x00000072
    2578:	65746e49 	.word	0x65746e49
    257c:	74656e72 	.word	0x74656e72
    2580:	6e6f4320 	.word	0x6e6f4320
    2584:	7463656e 	.word	0x7463656e
    2588:	206e6f69 	.word	0x206e6f69
    258c:	6f727245 	.word	0x6f727245
    2590:	00000072 	.word	0x00000072
    2594:	63656843 	.word	0x63656843
    2598:	0078526b 	.word	0x0078526b
    259c:	676e6950 	.word	0x676e6950
    25a0:	70736152 	.word	0x70736152
    25a4:	00000000 	.word	0x00000000
    25a8:	73736150 	.word	0x73736150
    25ac:	61746144 	.word	0x61746144
    25b0:	00000000 	.word	0x00000000
    25b4:	646e6148 	.word	0x646e6148
    25b8:	6f44656c 	.word	0x6f44656c
    25bc:	0000726f 	.word	0x0000726f
    25c0:	454c4449 	.word	0x454c4449
    25c4:	00000000 	.word	0x00000000
    25c8:	09632509 	.word	0x09632509
    25cc:	25097525 	.word	0x25097525
    25d0:	75250975 	.word	0x75250975
    25d4:	00000a0d 	.word	0x00000a0d
    25d8:	0000215c 	.word	0x0000215c
    25dc:	0000215c 	.word	0x0000215c
    25e0:	0000215c 	.word	0x0000215c
    25e4:	000020d4 	.word	0x000020d4
    25e8:	0000219e 	.word	0x0000219e
    25ec:	000021b8 	.word	0x000021b8
    25f0:	0000215c 	.word	0x0000215c
    25f4:	0000215c 	.word	0x0000215c
    25f8:	000020d4 	.word	0x000020d4
    25fc:	0000219e 	.word	0x0000219e
    2600:	51726d54 	.word	0x51726d54
    2604:	00000000 	.word	0x00000000
    2608:	20726d54 	.word	0x20726d54
    260c:	00637653 	.word	0x00637653

00002610 <_global_impure_ptr>:
    2610:	20000010                                ... 

00002614 <_init>:
    2614:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2616:	46c0      	nop			; (mov r8, r8)
    2618:	bcf8      	pop	{r3, r4, r5, r6, r7}
    261a:	bc08      	pop	{r3}
    261c:	469e      	mov	lr, r3
    261e:	4770      	bx	lr

00002620 <__init_array_start>:
    2620:	000023ed 	.word	0x000023ed

00002624 <__frame_dummy_init_array_entry>:
    2624:	000000dd                                ....

00002628 <_fini>:
    2628:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    262a:	46c0      	nop			; (mov r8, r8)
    262c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    262e:	bc08      	pop	{r3}
    2630:	469e      	mov	lr, r3
    2632:	4770      	bx	lr

00002634 <__fini_array_start>:
    2634:	000000b5 	.word	0x000000b5
